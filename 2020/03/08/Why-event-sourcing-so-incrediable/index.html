<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>事件溯源：它是什么，为何这么厉害 | 书到用时方恨少，砖到搬时才知沉</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">事件溯源：它是什么，为何这么厉害</h1><a id="logo" href="/.">书到用时方恨少，砖到搬时才知沉</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">事件溯源：它是什么，为何这么厉害</h1><div class="post-meta">Mar 8, 2020</div><div class="post-content"><h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>在我们讨论事件溯源之前，先简单介绍一下web开发的现状。当前流行的web开发本质上是数据库驱动的。在设计Web应用最开始的阶段，一般会对业务进行建模，并抽象成数据库模型。如果使用MySQL，意味着需要设计表结构，索引等；如果使用Mongo，则需要设计文档结构和集合。这种方式会潜移默化的引导开发者按照如下方式去设计：业务运转起来后会如何使用数据？<br><img src="https://raw.githubusercontent.com/vividcoding/vividcoding.github.io/master/images/202003/es_data_driven.png" alt="data table driven"></p>
<h3 id="这种思想存在三个潜在的根本问题："><a href="#这种思想存在三个潜在的根本问题：" class="headerlink" title="这种思想存在三个潜在的根本问题："></a>这种思想存在三个潜在的根本问题：</h3><h4 id="1-不能直观表达业务的目的"><a href="#1-不能直观表达业务的目的" class="headerlink" title="1. 不能直观表达业务的目的"></a>1. 不能直观表达业务的目的</h4><p>这种方式让我们不根据状态来思考和交流。比如我和你在希格码2层领盒饭的时候问遇到了一个熟人，问他“最近还好吗“，他回答我：”嗯，我有一个篮球，我会写PHP，我单身“。<br>这个回答是不是很奇怪？实际上我们从数据库中取出来数据的时候就是这样的。<br>如果他的回答是这样：<br>”我这周一买了一个新篮球，这周新启动的一个项目开始用PHP实现，最近加班比较多，上周五晚上10点11分女朋友跟我分手了“。<br>显而易见，第二种方式他告诉我上次见面到现在你发生了什么事情，这样我能根据上次的交谈得出你现在是什么样的状态，毕竟我们已经认识了。<br>概括一下，他只需要用最简单的方式告诉我最近他发生的事情即可。    </p>
<h4 id="2-单一数据模型"><a href="#2-单一数据模型" class="headerlink" title="2. 单一数据模型"></a>2. 单一数据模型</h4><p>在上述的设计中，我们读写都是基于同一种存储模型的。因此我们在设计的时候会考虑怎么写入数据以及怎么在设计的数据结构上做查询。这种方式对于简单的应用是非常高效的，比如：一个todo list，但是一旦这个todo list变成了一个很复杂的大型应用：时间管理综合解决方案blabla..，我们背后就会有各种服务来支撑这个大型应用，比如数据是不是要同步给手机Calendar？能不能直接从其他应用中把Todo同步过来？这些都是会面临的问题。随着业务的发展会出现各种各样的数据查询需求，如何让查询持续高效？传统的数据库在面临数据量巨大场景下变更索引或者加字段的成本都是比较高的，尽管它们做了很多优化让这些操作变得足够平滑，但是并没有从本质上解决问题，最终数据库将会变的不可维护，变更成本高昂。</p>
<h4 id="3-丢失业务关键信息"><a href="#3-丢失业务关键信息" class="headerlink" title="3. 丢失业务关键信息"></a>3. 丢失业务关键信息</h4><p>这个是最严重的问题。使用标准的表驱动系统时，你只能知道当前的状态，不会知道它是如何变成当前的状态的。如果我需要查询一个用户变更了多少次邮箱？你可能需要去流水日志里去查，但是流水日志非常多，因此又需要考虑流水日志如何存储，如何索引。如果需求是：有多少人往购物车里加过商品，又删掉了它，后来过了一个月他们又买了它。这些需求可能都需要拍个期，并且最关键的是，传统的实现都是对业务具有侵入性的，随着时间的流逝和产品的来来去去，需要维护的表，需要join的表会越来越多。</p>
<h2 id="事件溯源（Event-Sourcing"><a href="#事件溯源（Event-Sourcing" class="headerlink" title="事件溯源（Event Sourcing)"></a>事件溯源（Event Sourcing)</h2><p>事件溯源的思想是完全相反的。在系统存储设计的时候关心变化，而不是最终状态。它是使用事件序列来对系统进行建模的一种实践。</p>
<blockquote>
<p>举个栗子：现在我们有一个“购物车”，购物车可以往里添加商品、删除商品、结账。<br>一个购物车的生命周期按照事件序列的方式进行建模：</p>
</blockquote>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h4 id="1-创建购物车"><a href="#1-创建购物车" class="headerlink" title="1. 创建购物车"></a>1. 创建购物车</h4><h4 id="2-添加商品A到购物车"><a href="#2-添加商品A到购物车" class="headerlink" title="2. 添加商品A到购物车"></a>2. 添加商品A到购物车</h4><h4 id="3-添加商品B到购物车"><a href="#3-添加商品B到购物车" class="headerlink" title="3. 添加商品B到购物车"></a>3. 添加商品B到购物车</h4><h4 id="4-从购物车中移出商品A"><a href="#4-从购物车中移出商品A" class="headerlink" title="4. 从购物车中移出商品A"></a>4. 从购物车中移出商品A</h4><h4 id="5-结账"><a href="#5-结账" class="headerlink" title="5. 结账"></a>5. 结账</h4><p><img src="https://raw.githubusercontent.com/vividcoding/vividcoding.github.io/master/images/202003/event_driven.png" alt="data table driven"></p>
<p>这就是一个购物车的完整生命周期，从创建到结账。这就是事件溯源思想，我们可以基于这个事件序列提炼出业务行为的各种特征。<br>任何业务流程都可以按照这种思想进行抽象建模。实际上：每一个流程都按照一个事件来进行建模。我们和任意一个领域的专家讨论的时候，他们不懂计算机，不会跟你说“表”、“join”，除非你给他们灌输好了这些计算机的术语，他们只会告诉你业务流程，每一个步骤需要什么物料，如何加工物料，下一步做什么。</p>
<h3 id="如何实施业务规则？"><a href="#如何实施业务规则？" class="headerlink" title="如何实施业务规则？"></a>如何实施业务规则？</h3><p>问题来了，大部分业务都会存在一些约束，比如：没有准生证生超生孩子如果不交社会抚养费不给上户口，孩子也就没办法上学。这种规则显然不可能轻易打破。在上面购物车的例子中存在的约束是：一件商品需要存在于购物车中才可以被移除。不可能移除一个不在购物车里的商品，这种事件序列本身是不可能发生的。因此在实现这种约束的时候需要回答一个问题：“这个商品在不在购物车中？“，如何在无状态下实现这个逻辑。</p>
<p>解决这个问题的办法非常简单，你只需要检查添加该商品的事件是否发生过，并且之前没有移除事件发生，只要满足这两个条件即可认为移出购物车事件是可执行的，这就实现了我们的约束逻辑。</p>
<p>这是在使用事件溯源思想设计系统时解决业务问题的标准套路，即，对该实体发生过的事情进行片段或者完整的回放即可得到一个判断约束条件是否满足的状态。这种方式通常被称为“Projection the Events”，结果称为“投影”。</p>
<h3 id="事件溯源实现业务约束成本是否昂贵？"><a href="#事件溯源实现业务约束成本是否昂贵？" class="headerlink" title="事件溯源实现业务约束成本是否昂贵？"></a>事件溯源实现业务约束成本是否昂贵？</h3><p>答案是否定的。要实现业务约束一般只需要事件的一个微小的子集。实现过程从实体的历史事件中过滤出需要的部分，这就变成了一个简单的SELECT查询，将需要的事件从表张查询出来放到内存中做一次回放得到一个最终态。这种做法非常轻量，大部分的计算都在本地做，而不是写一个复杂的查询在数据库中做，因为我们在复杂业务实践时需要尽量避免在查询中使用计算表达式，为了提升吞吐量也需要尽量的减少和数据库之间的网络通信开销。</p>
<h3 id="如何将数据展示给用户？"><a href="#如何将数据展示给用户？" class="headerlink" title="如何将数据展示给用户？"></a>如何将数据展示给用户？</h3><p>如果每个状态的都由事件序列去重放出来的话，我们需要如何获得显示给用户的数据？是不是每次查询都需要对事件进行完整的重放然后得到最终结果？</p>
<p>答案是否定的，这么做简直荒谬。</p>
<p>取而代之的解决方案是在后台对数据进行构建，并立刻存入数据库中。这样当我们需要查询完整数据的时候只需要根据需求查询就可以了（一般是主键），实际上，这相当于用一个缓存存储了对象的最终状态。</p>
<p>到现在为止，你应该体会到了事件溯源思想的魅力所在。使用这种方式，我们抛弃了传统数据库设计范式，无需被现有的数据库表结构羁绊。每当需要新的数据组织形式的时候那就按照需要去自行重放并组织就好了。这给了不同业务读取数据充分的自由，弱水三千，你只取一瓢也是可以的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>前面我们在介绍事件溯源思想的时候已经提到了一些优势，接下来我们深入的介绍分析其更大的益处。</p>
<h4 id="1-短暂的数据结构，永存的事件流水"><a href="#1-短暂的数据结构，永存的事件流水" class="headerlink" title="1. 短暂的数据结构，永存的事件流水"></a>1. 短暂的数据结构，永存的事件流水</h4><p>由于所有的状态都来自于事件，你不在需要被数据的当前状态（组织形式以及具体的状态）所限制。如果需要一种新的数据视图，需要做的仅仅是按照你想要的方式做一次会放即可。和复杂的数据迁移脚本说再见吧，你只需要去用你需要的方式重放事件就可以把原来的数据抛弃了。</p>
<h4 id="2-和领域专家愉快的讨论业务问题"><a href="#2-和领域专家愉快的讨论业务问题" class="headerlink" title="2. 和领域专家愉快的讨论业务问题"></a>2. 和领域专家愉快的讨论业务问题</h4><p>前文提到过，一般行业专家不会按照计算机从业人员的思维去表述问题，而是会按照业务流程去描述。构建一个事件溯源的系统时，我们对他们原汁原味的描述进行建模来取代传统对这些信息进行提取，转换成计算机语言的方式，这样能避免因为产品或开发对业务的理解偏差产生的信息丢失问题。这样也能帮助我们与他们（领域专家）的沟通更加顺畅，因为产研在了解需求时会顺着他们的思维和表述方式去沟通，讨论，这让软件开发完全不一样了。</p>
<h4 id="3-极具表现力的模型"><a href="#3-极具表现力的模型" class="headerlink" title="3. 极具表现力的模型"></a>3. 极具表现力的模型</h4><p>事件溯源思想引导你把模型的事件作为第一个对象进行建模，而无需考虑各种对数据更新、查询的需求。这意味着可以最大限度的设计一个极度接近业务流程本身的模型出来。这种模型设计的思想可以避免因为传统的数据组织方式导致业务流程中状态变化的一些流程信息，将一些隐藏的很深的变化也能清晰的表述出来。所以说这种建模的方式具有很好的表现力，不仅有结果，还有结果产生的过程。</p>
<h4 id="4-上报，上报，上报"><a href="#4-上报，上报，上报" class="headerlink" title="4. 上报，上报，上报"></a>4. 上报，上报，上报</h4><p>大部分情况下上报的代码不需要再写在核心业务里了，需要不同的上报实际上也可以看作一种不同的数据组织方式，为它单独开发一个简单的脚本就可以实现，这样让所有上报变成了非侵入式的，并且历史的车轮压过的轨迹可以帮你解释所有的问题。想想都开心，我们有些业务总是不断的有新的上报需求，由于对业务不熟悉，对资源不熟悉等各种借口导致我们的业务代码里存在十几个甚至几十个上报，非常丑陋，甚至他们时串行的同步的，就算有数据上报的AGENT服务也是需要浪费很多的计算资源的。说的升华一下，这种数据模型设计方式让你拥有了一台时间机器，除了未来，哪里都可以去。</p>
<h4 id="5-微服务由此开启"><a href="#5-微服务由此开启" class="headerlink" title="5. 微服务由此开启"></a>5. 微服务由此开启</h4><p>微服务的好处网上有很多资料介绍，大家如何从传统的中心化服务向微服务过度也是各有神通。而事件溯源的模型设计方式让微服务化面临的跨系统交互问题迎刃而解，答案就是事件监听器。事件监听器监听事件，并执行重放，按照自己的方式组织数据，无需额外的改造成本即可让现有的业务平滑的过度。<br>举个例子，一篇文章的一个字段变化了，我们需要通知到五个下游，通过BOSS同步上报也好、RPC接口通知、通过binlog订阅、各种方式，侵入到业务代码里。这里不讨论代码写得是否优雅，效率是否高，传统的方式我们一般都是在业务代码里直接去做。好一点的会有框架的事件机制，可能更好的还能用异步队列去做。而事件溯源的方式将只需要在存储层将这个文章的变更按照一个事件写入的有序存储里（Kafka），后续动作交给事件的调度服务去完成，不同的服务之间的交互便解耦了。</p>
<h4 id="6-对数据库的要求不再喋喋不休"><a href="#6-对数据库的要求不再喋喋不休" class="headerlink" title="6. 对数据库的要求不再喋喋不休"></a>6. 对数据库的要求不再喋喋不休</h4><p>事件存储无需性能非常好的数据库或机器，一个简单的MySQL都能达到很高的吞吐能力，因为写入是顺序的，修改是不存在的。</p>
<h4 id="7-数据库更换成本很低"><a href="#7-数据库更换成本很低" class="headerlink" title="7. 数据库更换成本很低"></a>7. 数据库更换成本很低</h4><p>由于事件的数据结构非常简单，不管是传统的关系型数据库还是MongoDB还是OrientDB这类图数据库，都是可以用来存储事件的，可以非常低成本的更换存储方案。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>所有事务皆是有利有弊的，这是客观规律，不是鲁迅说的。下面是一些需要注意的问题：</p>
<h4 id="1-最终一致性"><a href="#1-最终一致性" class="headerlink" title="1. 最终一致性"></a>1. 最终一致性</h4><p>理论上，基于事件溯源思想设计的系统即是符合最终一致性的。这意味着，一个事件发生之后，其他系统不会立刻感知到，在他们收到并处理之前会有小于100ms的延迟来实现我们所说的最终一致性。也就是说，你不能保证你的系统里展示的数据就是当时最新的数据，听起来好像不可接受，实际上并不是，因为现在大部分的应用和服务是由人去发起的动作，这些动作本身就伴随着一定的延迟，几乎是无感知的，因为实际情况下这样的设计甚至会让整体的速度提升不少。老实说，这有点塞翁失马的感觉，符合最终一致性的系统是具备容错特点并且能应对服务中断的。如果你在使用微服务或者无状态架构构建一个分布式应用， </p>
<h4 id="2-事件升级"><a href="#2-事件升级" class="headerlink" title="2. 事件升级"></a>2. 事件升级</h4><p>事件的模型会随着时代的发展而变化，因此在最初设计事件模型时需要认真考虑其扩展性。当事件模型需要升级时，历史数据也需要被整体更新一遍，这件事可以是触发式的，并不一定要离线把事件做好，可以在读取事件时将事件模型升级到新版本。因此提前设计好事件升级的机制可以帮助你轻松应对这类问题。</p>
<h4 id="3-开发人员需要deprograming"><a href="#3-开发人员需要deprograming" class="headerlink" title="3. 开发人员需要deprograming"></a>3. 开发人员需要deprograming</h4><p>在实践过程中，开发人员需要首先转变开发的模式，从传统的先涉及表实体转为先设计实体变更模型，在开发过程中需要更多的去关注业务本身而不是考虑怎么写CRUD。</p>
<p>到这里大家可能已经感受到了事件溯源的魅力了，反正我的领导在看到这个思想的时候非常激动的让我们停止了数据库表设计的工作直接转向这种构建系统的思路上来。的确，在构建大型分布式业务系统时，这种方式让核心的数据模型设计本身可以不脱离实际业务流程，不做那些信息有损的抽象，讨论业务需求的时候能够尽量用业务领域专家的思维方式来沟通。学习的过程可能是坎坷的，相信我，这个不仅看起来美，真香！</p>
</div><div class="tags"></div><div class="post-nav"><a class="next" href="/2018/09/02/A-small-tip-about-mysql-latin1-charset/">MySQL latin1 字符集引起的一个小问题分析</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://vividcoding.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/interviews/" style="font-size: 15px;">interviews</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/mysql-查询优化/" style="font-size: 15px;">mysql 查询优化</a> <a href="/tags/php7-阅读源码/" style="font-size: 15px;">php7 阅读源码</a> <a href="/tags/MySQL-SQL-groupby/" style="font-size: 15px;">MySQL SQL groupby</a> <a href="/tags/opcache-php-optimization/" style="font-size: 15px;">opcache php optimization</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/03/08/Why-event-sourcing-so-incrediable/">事件溯源：它是什么，为何这么厉害</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/02/A-small-tip-about-mysql-latin1-charset/">MySQL latin1 字符集引起的一个小问题分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/15/why-using-an-integer-to-select-varchar-cause-a-full-table-scan/">为什么使用INT型数据查询varchar字段会导致全表扫描</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/26/PHP7-FPM-internels/">PHP7 FPM 启动源码分析<一></a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/18/select-max-top-n-rows-with-groupby/">按分组选出值最大的n行数据</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/17/http-post-methods-comparison/">HTTP POST 表单提交方式介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/17/2017-interviews/">2017 面试记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/18/things-about-opcache/">OPCache 工作机制</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">书到用时方恨少，砖到搬时才知沉.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>