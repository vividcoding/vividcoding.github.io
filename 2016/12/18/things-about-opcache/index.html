<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>OPCache 工作机制 | 书到用时方恨少，砖到搬时才知沉</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">OPCache 工作机制</h1><a id="logo" href="/.">书到用时方恨少，砖到搬时才知沉</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">OPCache 工作机制</h1><div class="post-meta">Dec 18, 2016</div><div class="post-content"><p>基于 PHP7 源码分析 opcache 内部工作机制<br><a id="more"></a></p>
<h1 id="一个请求的-np-Nginx-PHP-之旅"><a href="#一个请求的-np-Nginx-PHP-之旅" class="headerlink" title="一个请求的 np (Nginx - PHP) 之旅"></a>一个请求的 np (Nginx - PHP) 之旅</h1><ol>
<li>Nginx 监听 80 端口，接到请求后，通过 socket 将请求发到其 worker 上；</li>
<li>Worker 根据 Nginx 配置再将请求发到 php-fpm 管理的的进程池中；</li>
<li>php-fpm 根据请求调用 php-cgi 执行 php 脚本；</li>
<li>执行完的结果会被返回给 nginx。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/lephp/lephp.github.io/master/images/Nginx-PHP-Workflow.png" alt="nginx php workflow"></p>
<p>因为本文主要是讲 php 执行过程中 opcache 的作用，所以上面四个步骤暂时只需要关注第3点。</p>
<h2 id="两个概念"><a href="#两个概念" class="headerlink" title="两个概念"></a>两个概念</h2><h3 id="php-fpm"><a href="#php-fpm" class="headerlink" title="php-fpm"></a>php-fpm</h3><p>全称：php-fastcgi process manager, 主要干几件事</p>
<ul>
<li>管理 php-cgi 进程</li>
<li>管理 php-cgi 进程</li>
<li>管理 php-cgi 进程</li>
</ul>
<h3 id="php-cgi"><a href="#php-cgi" class="headerlink" title="php-cgi"></a>php-cgi</h3><p>全称：php-cgi, php 有两种运行方式，cli 和 cgi, cli 就是命令行执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/bin/php -f a.php</span><br></pre></td></tr></table></figure>
<p>cgi 就是所谓的 Common Gateway Interface（通用网关接口），详细可以去翻一下 《HTTP 权威指南》，php-cgi 就是用于提供给网站的 php 解释器。</p>
<h1 id="一次完整的脚本执行过程"><a href="#一次完整的脚本执行过程" class="headerlink" title="一次完整的脚本执行过程"></a>一次完整的脚本执行过程</h1><p>这是一个标准的脚本语言干的事情：</p>
<ol>
<li>词法分析 + 语法分析 =&gt; 生成语法树</li>
<li>通过语法树 =&gt; 生成操作码</li>
<li>按操作码的顺序一步一步执行</li>
<li>输出结果</li>
</ol>
<p><img src="https://raw.githubusercontent.com/lephp/lephp.github.io/master/images/php-execute-process.png" alt="php execute process"></p>
<p>每次请求过来php都会通过如上四步来处理请求，每次都是。但是实际业务运转中，很多流程其实是完全一样的，甚至连变量的值都一样，然而，解释编译过程仍然会去读取相同的代码来一遍，不禁想起一句话：</p>
<blockquote>
<p>越是简单重复的工作越能体现出制作者的心意</p>
</blockquote>
<p>能更快的把客户需要的东西送到他们手上也很重要！毫无疑问，这个过程中存在对资源的极大浪费，我们都知道词法的分析和解释以及编译都是极其消耗计算资源的过程，于是乎，用于缓存 OPCodes 的扩展应运而生。它只有一个目标，<strong>每个 PHP 脚本只被编译一次</strong>，然后将生成的 OPCodes 存储到共享内存区中，如此，其他的 php-fpm 进程都可以访问并使用共享缓存区中的 OPCodes。</p>
<p>这个方法能给 PHP 脚本的执行速度提升两倍以上！实际运用中，对于 include 几十几百个脚本的大型网站，其速度提升会超过 10 倍，这是因为 PHP 的编译器很慢，因为它需要将一堆具有语义的编程语言转换成机器能执行的操作码，尝试去理解产品经理的需求，并且要在保证安全和正确的前提下尽量生成流程最优的操作码序列。</p>
<p>PHP 中用于缓存 OPCodes 的扩展主要有：</p>
<ul>
<li>APC</li>
<li>XCache</li>
<li>Eaccelerator</li>
<li>OPCache（Zend Optimizer+)</li>
<li>…</li>
</ul>
<p>APC 可能很多 PHP 程序员用过或者正在用，但是 APC 已经不再更新很久了，如果可以，升级到 PHP7 吧！为了世界和平！ 更详细的信息可以在 <a href="https://en.wikipedia.org/wiki/List_of_PHP_accelerators" target="_blank" rel="noopener"><strong>Wikipedia:List of PHP accelerators</strong></a> 找到，这里就不做对比了，本文主要研究 OPCache。</p>
<h1 id="OPCache-简介"><a href="#OPCache-简介" class="headerlink" title="OPCache 简介"></a>OPCache 简介</h1><p>opcache 原称：Zend Optimizer+ ，是 Zend Server 的一个开源组件，在2013年3月中旬之后更名为 Zend Opcache。它从 PHP 5.5 开始就随着 PHP 一起发行，但是必须要在 php.ini 中打开才可以生效，它主要提供两个优化方向：</p>
<ul>
<li>OPCodes 和 Interned Strings 的缓存（用于进程间共享）</li>
<li>OPCodes 优化</li>
</ul>
<p>OPCache 触发 PHP 编译器启动，获取 OPCodes 然后将其缓存起来，所以在这个过程中同样可以做另外一件事：代码优化。</p>
<h1 id="OPCodes-和-Interned-Strings-的缓存"><a href="#OPCodes-和-Interned-Strings-的缓存" class="headerlink" title="OPCodes 和 Interned Strings 的缓存"></a>OPCodes 和 Interned Strings 的缓存</h1><p>让我们深入研究一下 opcache 的工作原理, 它的源代码在这里：<br> <a href="https://github.com/php/php-src/tree/PHP-7.0/ext/opcache" target="_blank" rel="noopener">php-src/ext/opcache</a></p>
<h2 id="共享内存模型"><a href="#共享内存模型" class="headerlink" title="共享内存模型"></a>共享内存模型</h2><p>前面提到了缓存的机制主要是将编译好的操作码放入共享内存提供给其他进程访问，UNIX 系统提供很多种进程间内存共享的方式，常用的有：</p>
<ul>
<li>System-V shm API</li>
<li>POSIX API</li>
<li>mmap API</li>
</ul>
<p>OPCache 会根据系统支持的情况选择合适的接口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择共享内存模型</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> zend_shared_memory_handler_entry handler_table[] = &#123;</span><br><span class="line">#ifdef USE_MMAP</span><br><span class="line">    &#123; <span class="string">"mmap"</span>, &amp;zend_alloc_mmap_handlers &#125;,</span><br><span class="line">#endif</span><br><span class="line">#ifdef USE_SHM</span><br><span class="line">    &#123; <span class="string">"shm"</span>, &amp;zend_alloc_shm_handlers &#125;,</span><br><span class="line">#endif</span><br><span class="line">#ifdef USE_SHM_OPEN</span><br><span class="line">    &#123; <span class="string">"posix"</span>, &amp;zend_alloc_posix_handlers &#125;,</span><br><span class="line">#endif</span><br><span class="line">#ifdef ZEND_WIN32</span><br><span class="line">    &#123; <span class="string">"win32"</span>, &amp;zend_alloc_win32_handlers &#125;,</span><br><span class="line">#endif</span><br><span class="line">    &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个配置项可用于配置首选共享内存模型，如果没有设置这个值，OPCache 会选择系统第一个可以使用的模型。</p>
<blockquote>
<p>opcache.preferred_memory_model // 用于设置首选共享内存模型</p>
</blockquote>
<p>OPCache 默认会使用的是 mmap, 它是一种很常见的内存模型, 详细可以参考 《UNIX 环境高级编程》。 在 OPCache 启动之后，它会从系统中申请一块内存用作共享内存，大小取决于 php.ini 中 <strong>opcache.memory_consumption</strong> 配置的内存大小，它只会申请一次，不会释放，不会碎片化 （稍后会提到为什么），建议配置 opcache.memory_consumption 时不要吝啬，因为对于 PHP 实现的 网站来说，应该绝大多数不需要超过 1GB 内存。OPCache 申请这些内存用来存放下列内容和数据：</p>
<ul>
<li>脚本数据结构，包含且不限于 OPCode 的缓存</li>
<li>Interned Strings</li>
<li>脚本的哈希表</li>
<li>全局 OPCache 共享内存的状态</li>
<li>…</li>
</ul>
<p>也就是说，这部分内存不仅仅用于存储可复用的操作码序列，而且会有一些 OPCache 自身需要的东西在里面， 并且每部分占用的比例是可以设置的。</p>
<p>先分别来看一下 OPCodes 缓存和 Interned Strings 共享：</p>
<h2 id="OPCodes-缓存-操作码缓存"><a href="#OPCodes-缓存-操作码缓存" class="headerlink" title="OPCodes 缓存(操作码缓存)"></a>OPCodes 缓存(操作码缓存)</h2><p>文章刚开始的时候介绍了 Nginx 监听 80 端口，接到请求后，通过 socket 将请求发到其 worker 上，而这个 worker 就是 php-fpm 的子进程，每个请求都对应一个 php-fpm 进程，看一下请求一个包含 FPM 简要启动过程的请求执行流程图（到 zend_compile_file())：</p>
<p><img src="https://raw.githubusercontent.com/lephp/lephp.github.io/master/images/FPM-START-TO-PHP-REQUEST-START.png" alt="php request startup"></p>
<p>简单解释一下这个过程，当用户启动 php-fpm 的时候，它会根据配置初始化各种依赖，准备好各种资源，然后根据配置启动一定数量的子进程，这些子进程就是用于处理请求的，主进程本身不处理请求，主进程只需要负责根据配置统一初始化好进程资源（包括 PHP 编译执行环境），fork() 出子进程出来，进入等待状态，一旦有请求进来，php-fpm 进程就会进入 php 脚本的执行过程。</p>
<p>从图中可以看出，当 php-fpm 启动的时候，会将 php 的环境准备好再接受请求，所以，当 php.ini 文件中打开了 opcache 扩展的情况下，执行 php 脚本开始前 opcache 扩展已经启动了。</p>
<p>下面就详细介绍 opcache 扩展启动的过程已经工作原理：</p>
<p>所有本文中所介绍的东西都基于一个基本法：<strong>将处理每个请求过程中作用相同的指针以及不会发生变化的内容全部存入共享内存</strong>。</p>
<p>针对相同的请求，PHP 编译器将从共享内存中直接取出编译好的操作码序列（op_array），绑定到当前处理该请求的 php-fpm 子进程中。PHP 编译器工作的时使用 Zend Memory Manager(ZMM) 来分配指针。 这种内存使用方式是和请求绑定的，每次请求结束之后 ZMM 会主动释放这些内存空间。很显然这些被分配的指针地址是在当前进程的堆栈中，并且不可以被其他进程所共享的。因此 OPCache 的工作就是把每个 PHP 编译器返回的数据结构都检查一遍，然后把他们都拷贝到一个共享存储区中。</p>
<p>这里提到的编译过程中所有被编译器所处理的东西都是不可变的，也就是”常量”。可变的数据会在运行时由 Zend Virtual Machine 创建，所以我们认为保存所有被编译器所处理过的数据到共享内存中都是安全的，因为它们不会再将来发生变化。</p>
<p>这些被保存的东西包括：函数、类、函数的指针、函数的操作码数组指针、类的常量，类中被声明的变量名和它们最终的默认值等等，后面将会详细介绍。</p>
<p>这样的内存模型是为了在最大程度上避免出现资源锁，后文中将会详细介绍锁的相关内容。有一个很基本的 OPCache 只在运行之前工作一次，而在运行过程中，OPCache 则是个安静的美男子：ZMM 会在进程的堆栈中 创建变量，而常量则直接从 OPCache 提供的共享内存中取。</p>
<p>那 OPCache 怎么做到这一点呢？它其实是通过钩子的方式将自己注入到编译器中，替代编译 PHP 脚本 过程中需要填充的数据结构，让编译器初始化一个 persistent_script 的结构并且赋值来替代 Zend Engine 表和其他内部结构。</p>
<p>下面是 persistent_script 的结构定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_persistent_script</span> &#123;</span></span><br><span class="line">    ulong          hash_value;</span><br><span class="line">    <span class="keyword">char</span>          *full_path;              <span class="comment">/* 绝对连接，并且软连接也是被解析过了 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>   full_path_len;</span><br><span class="line">    zend_op_array  main_op_array;          <span class="comment">/* opcode array ，操作码序列 */</span></span><br><span class="line">    HashTable      function_table;</span><br><span class="line">    HashTable      class_table;</span><br><span class="line">    <span class="keyword">long</span>           compiler_halt_offset;   <span class="comment">/* position of __HALT_COMPILER or -1 */</span></span><br><span class="line">    <span class="keyword">int</span>            ping_auto_globals_mask; <span class="comment">/* which autoglobals are used by the script */</span></span><br><span class="line">    <span class="keyword">accel_time_t</span>   timestamp;              <span class="comment">/* 脚本修改时间戳 */</span></span><br><span class="line">    zend_bool      corrupted;             <span class="comment">/* 是否过期 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ZEND_EXTENSION_API_NO &lt; PHP_5_3_X_API_NO</span></span><br><span class="line">    zend_uint      early_binding;          <span class="comment">/* the linked list of delayed declarations */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>          *mem;                    <span class="comment">/* shared memory area used by script structures */</span></span><br><span class="line">    <span class="keyword">size_t</span>         size;                   <span class="comment">/* size of used shared memory */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* All entries that shouldn't be counted in the ADLER32</span></span><br><span class="line"><span class="comment">     * checksum must be declared in this struct</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zend_persistent_script_dynamic_members</span> &#123;</span></span><br><span class="line">        <span class="keyword">time_t</span>       last_used;</span><br><span class="line">        ulong        hits;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> memory_consumption;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> checksum;</span><br><span class="line">        <span class="keyword">time_t</span>       revalidate;</span><br><span class="line">    &#125; dynamic_members;</span><br><span class="line">&#125; zend_persistent_script;</span><br></pre></td></tr></table></figure>
<p>当服务器第一次接到请求时，共享内存中是没有任何东西的，这时候 <strong>zend_accel_hash_str_find</strong> 肯定取不到任何东西，所以需要按照 OPCache 需要的配置去调用编译器编译出一份 persistent_script 结构，然后调用 <strong>cache_script_in_shared_memory</strong> 将这份数据结构存入共享内存中，并且继续将这个指针传给 <strong>zend_accel_load_script</strong> 函数设置覆盖CG, EG等全局变量中对应的一些值，这种机制保证了这个扩展设计的初衷：<strong>每个 PHP 脚本只被编译一次</strong>。</p>
<p>下面这段代码展示的是 OPCache 将编译器结构替换成 persistent_script 的过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 替代 zend_compile_file 函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">accel_startup</span><span class="params">(zend_extension *extension)</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  accelerator_orig_compile_file = zend_compile_file;</span><br><span class="line">  zend_compile_file = persistent_compile_file;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function">zend_op_array *<span class="title">persistent_compile_file</span><span class="params">(zend_file_handle *file_handle, <span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (!ZCG(accel_directives).revalidate_path) &#123;</span><br><span class="line">            <span class="comment">/* 用与脚本一一对应的 key 在共享内存中查找缓存 */</span></span><br><span class="line">            key = accel_make_persistent_key(file_handle-&gt;filename, <span class="built_in">strlen</span>(file_handle-&gt;filename), &amp;key_length);</span><br><span class="line">            <span class="keyword">if</span> (!key) &#123;</span><br><span class="line">                <span class="keyword">return</span> accelerator_orig_compile_file(file_handle, type);</span><br><span class="line">            &#125;</span><br><span class="line">            persistent_script = zend_accel_hash_str_find(&amp;ZCSG(hash), key, key_length); <span class="comment">//从共享内存中取出 persistent_script</span></span><br><span class="line">        &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (!persistent_script) &#123;</span><br><span class="line"></span><br><span class="line">  from_shared_memory = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//如果缓存中没有, 调用 opcache_compile_file 进行初始化</span></span><br><span class="line">  persistent_script = opcache_compile_file(file_handle, type, key, key ? key_length : <span class="number">0</span>, &amp;op_array);</span><br><span class="line">  <span class="keyword">if</span> (persistent_script) &#123;</span><br><span class="line">            <span class="comment">// 初始化成功，调用 cache_script_in_shared_memory 写入共享内存</span></span><br><span class="line">            persistent_script = cache_script_in_shared_memory(persistent_script, key, key ? key_length : <span class="number">0</span>, &amp;from_shared_memory);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (!persistent_script) &#123;</span><br><span class="line">            SHM_PROTECT();</span><br><span class="line">            <span class="keyword">return</span> op_array;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">  <span class="comment">// 这里将从 共享内存/文件缓存（php7）中拿到的 persistent_script 拷贝到处理请求的进程内存中</span></span><br><span class="line">  <span class="keyword">return</span> zend_accel_load_script(persistent_script, from_shared_memory);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个 persistent_script</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> zend_persistent_script *<span class="title">opcache_compile_file</span><span class="params">(zend_file_handle *file_handle, <span class="keyword">int</span> type, <span class="keyword">char</span> *key, zend_op_array **op_array_p)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">new_persistent_script = create_persistent_script();</span><br><span class="line"><span class="comment">/* 保存一份原值 */</span></span><br><span class="line">orig_active_op_array = CG(active_op_array);</span><br><span class="line">orig_function_table = CG(function_table);</span><br><span class="line">orig_class_table = CG(class_table);</span><br><span class="line">ZVAL_COPY_VALUE(&amp;orig_user_error_handler, &amp;EG(user_error_handler));</span><br><span class="line"><span class="comment">/* 用新的结构替换 */</span></span><br><span class="line">CG(function_table) = &amp;ZCG(function_table);</span><br><span class="line">EG(class_table) = CG(class_table) = &amp;new_persistent_script-&gt;class_table;</span><br><span class="line">ZVAL_UNDEF(&amp;EG(user_error_handler));</span><br><span class="line">    zend_try &#123;</span><br><span class="line">        orig_compiler_options = CG(compiler_options);</span><br><span class="line">        CG(compiler_options) |= ZEND_COMPILE_HANDLE_OP_ARRAY;</span><br><span class="line">        CG(compiler_options) |= ZEND_COMPILE_IGNORE_INTERNAL_CLASSES;</span><br><span class="line">        CG(compiler_options) |= ZEND_COMPILE_DELAYED_BINDING;</span><br><span class="line">        CG(compiler_options) |= ZEND_COMPILE_NO_CONSTANT_SUBSTITUTION;</span><br><span class="line">        op_array = *op_array_p = accelerator_orig_compile_file(file_handle, type);</span><br><span class="line">        CG(compiler_options) = orig_compiler_options;</span><br><span class="line">    &#125; zend_catch &#123;</span><br><span class="line">        op_array = <span class="literal">NULL</span>;</span><br><span class="line">        do_bailout = <span class="number">1</span>;</span><br><span class="line">        CG(compiler_options) = orig_compiler_options;</span><br><span class="line">    &#125; zend_end_try();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Restore originals */</span></span><br><span class="line">    CG(active_op_array) = orig_active_op_array;</span><br><span class="line">    CG(function_table) = orig_function_table;</span><br><span class="line">    EG(class_table) = CG(class_table) = orig_class_table;</span><br><span class="line">    EG(user_error_handler) = orig_user_error_handler;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//end of *opcache_compile_file</span></span><br></pre></td></tr></table></figure>
<p>从代码中可以看出，在 OPCache 插件初始化函数 <strong>accel_startup</strong> 中，默认编译器 <strong>zend_compile_file</strong> 被替换成了 <strong>persistent_compile_file</strong>，而 persistent_compile_file 中如果从共享内存中拿不到 persistent_script(还有其他原因，比如过期等) 则会调用 <strong>opcache_compile_file</strong> 重新编译一份新的 <strong>persistent_script</strong>，并把得到的结果保存到共享内存中提供给其他的进程使用。</p>
<p>上面这段代码中，有四个编译选项被设置，分别是</p>
<ul>
<li><p>ZEND_COMPILE_HANDLE_OP_ARRAY</p>
<blockquote>
<p>启用 zend_extension_op_array_handler</p>
</blockquote>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (CG(compiler_options) &amp; ZEND_COMPILE_HANDLE_OP_ARRAY) &#123;</span><br><span class="line">        <span class="keyword">if</span> (zend_extension_flags &amp; ZEND_EXTENSIONS_HAVE_OP_ARRAY_HANDLER) &#123;</span><br><span class="line">            zend_llist_apply_with_argument(&amp;zend_extensions, (<span class="keyword">llist_apply_with_arg_func_t</span>) zend_extension_op_array_handler, op_array);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<ul>
<li><p>ZEND_COMPILE_IGNORE_INTERNAL_CLASSES</p>
<blockquote>
<p>忽略内部类</p>
</blockquote>
</li>
<li><p>ZEND_COMPILE_DELAYED_BINDING</p>
<blockquote>
<p>延迟绑定</p>
</blockquote>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (((ce = zend_lookup_class_ex(Z_STR_P(parent_name), parent_name + <span class="number">1</span>, <span class="number">0</span>)) == <span class="literal">NULL</span>) ||</span><br><span class="line">                    ((CG(compiler_options) &amp; ZEND_COMPILE_IGNORE_INTERNAL_CLASSES) &amp;&amp;</span><br><span class="line">                     (ce-&gt;type == ZEND_INTERNAL_CLASS))) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (CG(compiler_options) &amp; ZEND_COMPILE_DELAYED_BINDING) &#123;</span><br><span class="line">                        <span class="keyword">uint32_t</span> *opline_num = &amp;CG(active_op_array)-&gt;early_binding;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">while</span> (*opline_num != (<span class="keyword">uint32_t</span>)<span class="number">-1</span>) &#123;</span><br><span class="line">                            opline_num = &amp;CG(active_op_array)-&gt;opcodes[*opline_num].result.opline_num;</span><br><span class="line">                        &#125;</span><br><span class="line">                        *opline_num = opline - CG(active_op_array)-&gt;opcodes;</span><br><span class="line">                        opline-&gt;opcode = ZEND_DECLARE_INHERITED_CLASS_DELAYED;</span><br><span class="line">                        opline-&gt;result_type = IS_UNUSED;</span><br><span class="line">                        opline-&gt;result.opline_num = <span class="number">-1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ZEND_COMPILE_NO_CONSTANT_SUBSTITUTION</li>
</ul>
<blockquote>
<p>在编译阶段禁用常量代替</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (c &amp;&amp; (</span><br><span class="line">          ((c-&gt;flags &amp; CONST_PERSISTENT) &amp;&amp; !(CG(compiler_options) &amp; ZEND_COMPILE_NO_PERSISTENT_CONSTANT_SUBSTITUTION))</span><br><span class="line">       || (Z_TYPE(c-&gt;value) &lt; IS_OBJECT &amp;&amp; !(CG(compiler_options) &amp; ZEND_COMPILE_NO_CONSTANT_SUBSTITUTION))</span><br><span class="line">    )) &#123;</span><br><span class="line">        ZVAL_DUP(zv, &amp;c-&gt;value);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Substitute true, false and null (including unqualified usage in namespaces) */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *lookup_name = ZSTR_VAL(name);</span><br><span class="line">        <span class="keyword">size_t</span> lookup_len = ZSTR_LEN(name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!is_fully_qualified) &#123;</span><br><span class="line">            zend_get_unqualified_name(name, &amp;lookup_name, &amp;lookup_len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        c = zend_lookup_reserved_const(lookup_name, lookup_len);</span><br><span class="line">        <span class="keyword">if</span> (c) &#123;</span><br><span class="line">            ZVAL_DUP(zv, &amp;c-&gt;value);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这几个选项主要是为了告诉编译器少做点无用功，让 OPCache 只做它能做和该做的事情。</p>
<p>OPCache 关注下面几种数据结构：</p>
<ul>
<li>脚本中的函数 CG(function_table);</li>
<li>脚本中的类 CG(class_table);</li>
<li>脚本的 OPArray CG(active_op_array)</li>
<li>脚本的文件路径</li>
<li>脚本内容本身</li>
</ul>
<p>OPCache 在内存管理上非常聪明，它知道它该做的事情是什么：尽量快的读写缓存。所以它不会释放内存，过期的内容占用的地址空间会被置为 wasted , 这中设计最大化的减少了内存碎片的产生，每当达到设置的内存使用上限时，会触发一次 重启，相比较花大量的精力去管理内存空间，却只是为了应付大量的 http 短连接，一次简单的重启更实用。</p>
<p>上面提到的缓存的第一步是计算数据大小，下面是它的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint <span class="title">zend_accel_script_persist_calc</span><span class="params">(zend_persistent_script *new_persistent_script, <span class="keyword">char</span> *key, <span class="keyword">unsigned</span> <span class="keyword">int</span> key_length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    new_persistent_script-&gt;mem = <span class="literal">NULL</span>;</span><br><span class="line">    new_persistent_script-&gt;size = <span class="number">0</span>;</span><br><span class="line">    new_persistent_script-&gt;arena_mem = <span class="literal">NULL</span>;</span><br><span class="line">    new_persistent_script-&gt;arena_size = <span class="number">0</span>;</span><br><span class="line">    new_persistent_script-&gt;corrupted = <span class="number">0</span>;</span><br><span class="line">    ZCG(current_persistent_script) = new_persistent_script;</span><br><span class="line"></span><br><span class="line">    ADD_DUP_SIZE(new_persistent_script, <span class="keyword">sizeof</span>(zend_persistent_script));</span><br><span class="line">    <span class="keyword">if</span> (key) &#123;``</span><br><span class="line">        ADD_DUP_SIZE(key, key_length + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* script is not going to be saved in SHM */</span></span><br><span class="line">        new_persistent_script-&gt;corrupted = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ADD_STRING(new_persistent_script-&gt;full_path);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __SSE2__</span></span><br><span class="line">    <span class="comment">/* Align size to 64-byte boundary */</span></span><br><span class="line">    new_persistent_script-&gt;size = (new_persistent_script-&gt;size + <span class="number">63</span>) &amp; ~<span class="number">63</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    zend_accel_persist_class_table_calc(&amp;new_persistent_script-&gt;class_table);</span><br><span class="line">    zend_hash_persist_calc(&amp;new_persistent_script-&gt;function_table, zend_persist_op_array_calc);</span><br><span class="line">    zend_persist_op_array_calc_ex(&amp;new_persistent_script-&gt;main_op_array);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __SSE2__</span></span><br><span class="line">    <span class="comment">/* Align size to 64-byte boundary */</span></span><br><span class="line">    new_persistent_script-&gt;arena_size = (new_persistent_script-&gt;arena_size + <span class="number">63</span>) &amp; ~<span class="number">63</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    new_persistent_script-&gt;size += new_persistent_script-&gt;arena_size;</span><br><span class="line">    new_persistent_script-&gt;corrupted = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ZCG(current_persistent_script) = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_persistent_script-&gt;size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面计算地址空间大小的实现就看出我们缓存的内容是：</p>
<ul>
<li>脚本中的函数 &amp;new_persistent_script-&gt;function_table</li>
<li>脚本中的类 &amp;new_persistent_script-&gt;class_table</li>
<li>脚本的 OPArray &amp;new_persistent_script-&gt;main_op_array</li>
<li>脚本的文件路径 new_persistent_script-&gt;full_path</li>
<li>脚本内容本身 sizeof(zend_persistent_script)</li>
</ul>
<p>小结一下缓存 OPCodes 的流程:</p>
<ul>
<li>使用与脚本一一对应的 key 去共享内存中查找已缓存的脚本<ul>
<li>如果找到了并且未过期，那就调用 <strong>zend_accel_load_script</strong> 将其拷贝到当前进程的堆栈中</li>
<li>如果未找到，则调用 <strong>opcache_compile_file</strong> 初始化，然后将新鲜的结果通过调用 <strong>cache_script_in_shared_memory</strong> 存入共享内存中</li>
</ul>
</li>
</ul>
<p>这里面会涉及到内存管理，在后面的篇幅中会介绍。</p>
<p>除了 OPCodes 可被缓存之外，Interned Strings 也可以被缓存。</p>
<h2 id="共享-Interned-Strings"><a href="#共享-Interned-Strings" class="headerlink" title="共享 Interned Strings"></a>共享 Interned Strings</h2><h3 id="什么是-Interned-Strings？"><a href="#什么是-Interned-Strings？" class="headerlink" title="什么是 Interned Strings？"></a>什么是 Interned Strings？</h3><p>Interned Strings 是 PHP5.4 之后加入的一种很成熟的内存优化机制，简单解释，当 PHP 编译器遇到一个字符串，它就会把它存入一段特殊的内存中，在之后每次碰到相同的字符串时会复用之前的指针。如果你想知道更深入的东西，可以读一下 <a href="http://jpauli.github.io/2015/09/18/php-string-management.html#interned-strings" target="_blank" rel="noopener">php string management</a> 。</p>
<h3 id="共享机制"><a href="#共享机制" class="headerlink" title="共享机制"></a>共享机制</h3><p>Interned Strings 的工作原理如下图：</p>
<p><img src="https://raw.githubusercontent.com/lephp/lephp.github.io/master/images/w1664.png" alt="php string"></p>
<p>不过，上面这种复用的方式是基于每个进程的，不同的进程之间并不能共享这块缓存。如下图所示：<br><img src="https://raw.githubusercontent.com/lephp/lephp.github.io/master/images/two-workers.png" alt="two workers"></p>
<p>这样在高并发的情况下会浪费大量宝贵的内存空间，但是如果使用如下的方式就能解决内存浪费的问题了：<br><img src="https://raw.githubusercontent.com/lephp/lephp.github.io/master/images/share-interned-strings.png" alt="share interned-strings"></p>
<p>使用 OPCache 把字符串都缓存在一个共享内存里就可以让这部分内容给进程池中的所有 php-fpm worker 读取了。通过调整 <strong>opcache.interned_strings_buffer</strong> 的值可以控制字符串的缓存占用的存储大小，如果太小的话， OPCache 并不会重启，只是 interned_strings_buffer 不能再增加了，不能命中的将会继续使用 php-fpm 处理请求的子进程自己的私有内存。所以如果允许的话，可以根据需要调大这个值。</p>
<blockquote>
<p>Interned Strings 就是 PHP 编译器运行过程中遇到的每一个字符串：变量名、类名、方法名、字符串值、注释，而且注释一般都是一大段文本，它们会吃掉很多内存！</p>
</blockquote>
<p>那么 OPCache 怎么实现这一机制呢？答案当然在源码里：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">accel_startup</span><span class="params">(zend_extension *extension)</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">switch</span> (zend_shared_alloc_startup(ZCG(accel_directives).memory_consumption)) &#123;</span><br><span class="line">    <span class="keyword">case</span> ALLOC_SUCCESS:</span><br><span class="line">      <span class="keyword">if</span> (zend_accel_init_shm() == FAILURE) &#123;</span><br><span class="line">        accel_startup_ok = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ALLOC_FAILURE:</span><br><span class="line">      accel_startup_ok = <span class="number">0</span>;</span><br><span class="line">      zend_accel_error(ACCEL_LOG_FATAL, <span class="string">"Failure to initialize shared memory structures - probably not enough shared memory."</span>);</span><br><span class="line">      <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    <span class="keyword">case</span> SUCCESSFULLY_REATTACHED:</span><br><span class="line">      zend_shared_alloc_lock();</span><br><span class="line">      accel_shared_globals = (zend_accel_shared_globals *) ZSMMG(app_shared_globals);</span><br><span class="line">      orig_new_interned_string = zend_new_interned_string;</span><br><span class="line">      orig_interned_strings_snapshot = zend_interned_strings_snapshot;</span><br><span class="line">      orig_interned_strings_restore = zend_interned_strings_restore;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 这里用 OPCache 中几个实现替代了原有的实现，用于当出现新的 interned string 时，写入共享内存</span></span><br><span class="line">      zend_new_interned_string = accel_new_interned_string_for_php;</span><br><span class="line">      zend_interned_strings_snapshot = accel_interned_strings_snapshot_for_php;</span><br><span class="line">      zend_interned_strings_restore = accel_interned_strings_restore_for_php;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">ifndef</span> ZTS</span></span><br><span class="line">      <span class="comment">// 当不是线程安全的时候，调用此函数将 interned strings 从共享内存中拷贝到当前进程内存中</span></span><br><span class="line">      accel_use_shm_interned_strings();</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      zend_shared_alloc_unlock();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FAILED_REATTACHED:</span><br><span class="line">      accel_startup_ok = <span class="number">0</span>;</span><br><span class="line">      zend_accel_error(ACCEL_LOG_FATAL, <span class="string">"Failure to initialize shared memory structures - can not reattach to exiting shared memory."</span>);</span><br><span class="line">      <span class="keyword">return</span> SUCCESS;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> ENABLE_FILE_CACHE_FALLBACK</span></span><br><span class="line">    <span class="keyword">case</span> ALLOC_FALLBACK:</span><br><span class="line">      zend_shared_alloc_lock();</span><br><span class="line">      fallback_process = <span class="number">1</span>;</span><br><span class="line">      zend_accel_init_auto_globals();</span><br><span class="line">      zend_shared_alloc_unlock();</span><br><span class="line">      <span class="keyword">goto</span> file_cache_fallback;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个实现的方式还是比较简单的，需要注意的是，这个特性不支持线程安全的PHP版本，前面有提到使用的 php-fpm 模式一个任务只由一个子进程处理，不存在线程安全隐忧，不需要特别使用线程安全版本的php，所以是可以享受到这个优势的。</p>
<p>讲到这里，我们已经把 OPCache 在缓存上的两个大的点覆盖到了：</p>
<ul>
<li>OPCodes 缓存</li>
<li>Interned Strings 共享</li>
</ul>
<p>这两者都和用于进程间资源共享的内存离不开，这块内存区域的管理对于性能提升也至关重要，这就引入了另一个话题，那就是锁。</p>
<h2 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h2><p>OPCache 的内存锁机制很简单：每个尝试往共享内存里写入内容的时候都会使用互斥锁，同时只有一个进程可以写，但是可以同时又很多进程同时读，写操作未完成时并不会阻止同时发生的读操作。</p>
<p>所以服务器运行过程中 OPCache 中出现死锁的概率比较低，但是每次你部署新的代码后，如果流量很大的话，可能会造成大量的写操作积压，这是因为当第一个获得写入机会的进程完成后，其他相同请求编译的结果会因为共享内存已经存在相同的内容而被其替代，这造成了极大的资源浪费，等于这些因为拿不到写机会的进程都干了无用功。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* exclusive lock */</span></span><br><span class="line">zend_shared_alloc_lock(TSRMLS_C);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if we still need to put the file into the cache (may be it was</span></span><br><span class="line"><span class="comment"> * already stored by another process. This final check is done under</span></span><br><span class="line"><span class="comment"> * exclusive lock) */</span></span><br><span class="line">bucket = zend_accel_hash_find_entry(&amp;ZCSG(hash), new_persistent_script-&gt;full_path, new_persistent_script-&gt;full_path_len + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (bucket) &#123;</span><br><span class="line">    zend_persistent_script *existing_persistent_script = (zend_persistent_script *)bucket-&gt;data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!existing_persistent_script-&gt;corrupted) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ZCG(accel_directives).revalidate_path &amp;&amp;</span><br><span class="line">            (!ZCG(accel_directives).validate_timestamps ||</span><br><span class="line">             (new_persistent_script-&gt;timestamp == existing_persistent_script-&gt;timestamp))) &#123;</span><br><span class="line">            zend_accel_add_key(key, key_length, bucket TSRMLS_CC);</span><br><span class="line">        &#125;</span><br><span class="line">        zend_shared_alloc_unlock(TSRMLS_C);</span><br><span class="line">        <span class="keyword">return</span> new_persistent_script;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>怎么解决这个问题呢？有一种办法就是短暂（一秒内）切断服务，然后把所有的页面或接口都调用一遍，保证 OPCache 的共享内存中都已经刷新了一遍内容。这个方法很粗暴，从服务可用性角度说肯定有所损失，但是为了避免出现可能的死锁导致更严重的事故也许主动切断几秒服务可能，甚至前端配合消息队列等设计几乎可以将用户感知降到0，这方面这里就不赘述了。</p>
<p>另外一个问题更值得重视：避免在 php 脚本运行中写 .php 文件，然后还要去用它。原因是，一旦程序要使用一个在运行过程中动态生成的代码，并发量很高的时候意味着每一个 php worker 都会尝试去编译它，这就会导致锁的发生。如果你确实需要这么做，opcache 有一个选项可以配置黑名单： opcache.blacklist-filename。</p>
<p>从技术角度，OPCache 的锁机制并不是很健壮，但是它在 Unix 生态里有很好的兼容性，因为它使用的是 fcntl() 调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ext/opcache/zend_shared_alloc.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zend_shared_alloc_lock</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ZEND_WIN32</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ZTS</span></span><br><span class="line">	tsrm_mutex_lock(zts_lock);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">	<span class="comment">/* this will happen once per process, and will un-globalize mem_write_lock */</span></span><br><span class="line">	<span class="keyword">if</span> (mem_write_lock.l_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">		mem_write_lock.l_pid = getpid();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (fcntl(lock_file, F_SETLKW, &amp;mem_write_lock) == <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			zend_accel_error(ACCEL_LOG_ERROR, <span class="string">"Cannot create lock - %s (%d)"</span>, strerror(errno), errno);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	zend_shared_alloc_lock_win32();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	ZCG(locked) = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="OPCache-对内存的使用"><a href="#OPCache-对内存的使用" class="headerlink" title="OPCache 对内存的使用"></a>OPCache 对内存的使用</h2><p>先回顾一下 OPCache 与内存相关的几个特点：</p>
<ul>
<li>OPCache 在 php-fpm 的 master 启动的时候就申请一块内存，所有的 slave 可共享</li>
<li>OPCache 不会释放共享内存</li>
<li>OPCache 在写共享内存的时候会使用 fcntl() 执行 F_SETLKW</li>
<li>共享内存用于以下几个方面<ul>
<li>脚本数据结构缓存，包括但不限于 OPCodes</li>
<li>Interned Strings 缓存</li>
<li>脚本的 HashTable</li>
<li>OPCache 的全局状态信息</li>
</ul>
</li>
</ul>
<p>这些特性对提升 web 服务性能帮助很大，但是：</p>
<blockquote>
<p>世界上没有什么是不过期的</p>
</blockquote>
<p>那 OPCache 怎么判断一个对象的缓存是否过期？阅读 opcache 的配置文档会发现两个很明显相关的选项：</p>
<ul>
<li>opcache.validate_timestamps</li>
<li>opcache.revalidate_freq</li>
<li>opcache.revalidate_path</li>
</ul>
<p>当 php.ini 中打开了 opcache.validate_timestamps 选项时，OPCache 的编译阶段（persistent_compile_file()）会调用 validate_timestamp_and_record() 检查缓存中脚本的时间戳和文件的时间戳。实现代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function">zend_op_array *<span class="title">persistent_compile_file</span><span class="params">(zend_file_handle *file_handle, <span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* If script is found then validate_timestamps if option is enabled */</span></span><br><span class="line">	<span class="keyword">if</span> (persistent_script &amp;&amp; ZCG(accel_directives).validate_timestamps) &#123;</span><br><span class="line">    <span class="comment">// 校验时间戳</span></span><br><span class="line">		<span class="keyword">if</span> (validate_timestamp_and_record(persistent_script, file_handle) == FAILURE) &#123;</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">validate_timestamp_and_record</span><span class="params">(zend_persistent_script *persistent_script, zend_file_handle *file_handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ZCG(accel_directives).revalidate_freq &amp;&amp;</span><br><span class="line">	    persistent_script-&gt;dynamic_members.revalidate &gt;= ZCG(request_time)) &#123;</span><br><span class="line">        <span class="comment">// 如果设置了 revalidate_freq 并且 缓存中的 persistent_script 存的下一次检查脚本时间仍然在请求发生之后，则不检查</span></span><br><span class="line">		<span class="keyword">return</span> SUCCESS;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (do_validate_timestamps(persistent_script, file_handle) == FAILURE) &#123;</span><br><span class="line">    <span class="comment">// else 检查时间戳</span></span><br><span class="line">		<span class="keyword">return</span> FAILURE;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// else 检查通过，不需要更新缓存中的内容，但是更新 下一次检查时间</span></span><br><span class="line">		persistent_script-&gt;dynamic_members.revalidate = ZCG(request_time) + ZCG(accel_directives).revalidate_freq;</span><br><span class="line">		<span class="keyword">return</span> SUCCESS;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">static</span> zend_persistent_script *<span class="title">opcache_compile_file</span><span class="params">(zend_file_handle *file_handle, <span class="keyword">int</span> type, <span class="keyword">char</span> *key, <span class="keyword">unsigned</span> <span class="keyword">int</span> key_length, zend_op_array **op_array_p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (ZCG(accel_directives).validate_timestamps) &#123;</span><br><span class="line">		<span class="comment">/* Obtain the file timestamps, *before* actually compiling them,</span></span><br><span class="line"><span class="comment">		 * otherwise we have a race-condition.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		new_persistent_script-&gt;timestamp = timestamp;</span><br><span class="line">    <span class="comment">// 记录下一次需要检查脚本是否变更的时间</span></span><br><span class="line">		new_persistent_script-&gt;dynamic_members.revalidate = ZCG(request_time) + ZCG(accel_directives).revalidate_freq;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>那么，如果缓存过期了怎么办？再来看看这一段代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 校验时间戳</span></span><br><span class="line"><span class="keyword">if</span> (validate_timestamp_and_record(persistent_script, file_handle) == FAILURE) &#123;</span><br><span class="line">zend_shared_alloc_lock();</span><br><span class="line"><span class="keyword">if</span> (!persistent_script-&gt;corrupted) &#123;</span><br><span class="line">  persistent_script-&gt;corrupted = <span class="number">1</span>;</span><br><span class="line">  persistent_script-&gt;timestamp = <span class="number">0</span>;</span><br><span class="line">  ZSMMG(wasted_shared_memory) += persistent_script-&gt;dynamic_members.memory_consumption;</span><br><span class="line">  <span class="keyword">if</span> (ZSMMG(memory_exhausted)) &#123;</span><br><span class="line">    zend_accel_restart_reason reason =</span><br><span class="line">      zend_accel_hash_is_full(&amp;ZCSG(hash)) ? ACCEL_RESTART_HASH : ACCEL_RESTART_OOM;</span><br><span class="line">    zend_accel_schedule_restart_if_necessary(reason);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">zend_shared_alloc_unlock();</span><br><span class="line">persistent_script = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从中可以看出，OPCache 会首先调用 <strong>zend_shared_alloc_lock()</strong>，然后将 persistent_script 的 设置为 corrupted，然后再判断共享内存又没有被标记 memory_exhausted=1，如果已经满了，那就调用 <strong>zend_accel_schedule_restart_if_necessary();</strong>，这个函数的实现如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void zend_accel_schedule_restart_if_necessary(zend_accel_restart_reason reason)</span><br><span class="line">&#123;</span><br><span class="line">	if ((((double) ZSMMG(wasted_shared_memory)) / ZCG(accel_directives).memory_consumption) &gt;= ZCG(accel_directives).max_wasted_percentage) &#123;</span><br><span class="line">    // 如果已经置为 wasted 的内存空间已经大于 php.ini 中设置的最大比例，则计划重启</span><br><span class="line"> 		zend_accel_schedule_restart(reason);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以，已经被设置为 wasted 的内存大于（opcache.max_wasted_percentage）设置的比例时，会触发 OPCache 的重启机制，它的重启机制是很复杂的，准备再另外一篇中重点解析。因为 OPCache 的重启是会锁住共享内存，重设状态，完全清理空间，然后再释放锁，一旦在流量很高的时候频繁触发重启，那带来的性能影响将是灾难性的。所以对性能有高要求的话有一条军规：</p>
<blockquote>
<p><strong>永远不要超出共享内存</strong></p>
</blockquote>
<p>如何做到这一点，或者说避免出现这种情况的做法是在线上服务器上关闭 validate_timestamps ，这种做法可以保证你永远不会触发重启，可以按照下面的步骤部署新的代码：</p>
<ul>
<li>切断流量</li>
<li>清空 Opcache，使用 opcache_reset() 或者直接重启 FPM</li>
<li>部署新版本代码</li>
<li>重启 FPM, 对所有的页面、接口都遍历执行一遍</li>
<li>切回流量</li>
</ul>
<p>这些步骤用几十行 shell 脚本就可以搞定，如果有一些请求一直无法结束导致 fpm 无法完成重启可以直接 kill -9 强制杀死进程。还有一种可靠的方式是：使用灰度发布，这种方式一般适用于大型线上项目，可以最大程度保证服务平滑切换。</p>
<p>另外和这个话题相关的有一个问题：<br>在部署代码的时候我们遇到过一个很常见的问题，那就是刚部署的代码不能立即看到效果，这让产品很抓狂。经过分析发现，这是因为部署代码的方式使用的是常见的先部署代码，再修改软连接的目标目录到新的代码目录下的方式，而 php-fpm 得到的访问请求是一个软连接，而缓存中 realpath_cache 仍然指向老的代码地址，故而新发布的代码没有生效。解决这个问题有多种办法，我们使用的是在 nginx 层配置成绝对路径，很好的解决了问题。</p>
<h1 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h1><p>到这里，OPCache 缓存部分的内容基本介绍完了，主要就是涉及到 OPCodes 缓存和 Interned Strings 缓存两大块，然后就是共享内存的管理也很重要，希望对大家开发和性能优化有一些指导意义，抽空再分析一下操作码优化这一块的内容。</p>
<p>因为个人能力有限，所以文中有一些不准确的地方敬请指出。<a href="mailto:vaivei@foxmail.com" target="_blank" rel="noopener">vaivei@foxmail.com</a></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>本文相当多的内容源自: <strong><a href="http://jpauli.github.io/2015/03/05/opcache.html" target="_blank" rel="noopener">PHP’s OPCache extension review</a></strong></p>
<ul>
<li><p><a href="http://huoding.com/2016/05/27/515" target="_blank" rel="noopener">如何正确发布PHP代码 - 火丁</a></p>
</li>
<li><p><a href="http://jpauli.github.io/2015/09/18/php-string-management.html" target="_blank" rel="noopener">PHP strings management</a></p>
</li>
<li><p><a href="http://php.net/manual/en/opcache.configuration.php" target="_blank" rel="noopener">opcache configuration</a></p>
</li>
<li><p><a href="http://taobaofed.org/blog/2015/11/24/nodejs-php-process-manager/" target="_blank" rel="noopener">浅谈 Node.js 和 PHP 进程管理</a></p>
</li>
<li><p><a href="https://github.com/php/php-src" target="_blank" rel="noopener">PHP 源代码</a></p>
</li>
<li><p>使用 <a href="http://opengrok.github.io/OpenGrok/" target="_blank" rel="noopener">Opengrok</a> 阅读源代码</p>
</li>
</ul>
</div><div class="tags"><a href="/tags/opcache-php-optimization/">opcache php optimization</a></div><div class="post-nav"><a class="pre" href="/2017/05/17/2017-interviews/">2017 面试记录</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://vividcoding.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/interviews/" style="font-size: 15px;">interviews</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/mysql-查询优化/" style="font-size: 15px;">mysql 查询优化</a> <a href="/tags/php7-阅读源码/" style="font-size: 15px;">php7 阅读源码</a> <a href="/tags/MySQL-SQL-groupby/" style="font-size: 15px;">MySQL SQL groupby</a> <a href="/tags/opcache-php-optimization/" style="font-size: 15px;">opcache php optimization</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/03/08/Why-event-sourcing-so-incrediable/">事件溯源：它是什么，为何这么厉害</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/02/A-small-tip-about-mysql-latin1-charset/">MySQL latin1 字符集引起的一个小问题分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/15/why-using-an-integer-to-select-varchar-cause-a-full-table-scan/">为什么使用INT型数据查询varchar字段会导致全表扫描</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/26/PHP7-FPM-internels/">PHP7 FPM 启动源码分析<一></a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/18/select-max-top-n-rows-with-groupby/">按分组选出值最大的n行数据</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/17/http-post-methods-comparison/">HTTP POST 表单提交方式介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/17/2017-interviews/">2017 面试记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/18/things-about-opcache/">OPCache 工作机制</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">书到用时方恨少，砖到搬时才知沉.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>