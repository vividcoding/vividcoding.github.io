{"pages":[{"title":"标签","permalink":"https://vividcoding.github.io/tags/index.html","text":""}],"posts":[{"title":"MySQL latin1 字符集引起的一个小问题分析","permalink":"https://vividcoding.github.io/2018/09/02/A-small-tip-about-mysql-latin1-charset/","text":"神勇的latin1啥都能存，但是要慎用。 场景DDL1234567CREATE TABLE `t_articles` ( `id` int(11) NOT NULL AUTO_INCREMENT, `article_id` varchar(14) NOT NULL, `sub_category_cn` varchar(32) NOT NULL DEFAULT '', PRIMARY KEY (`id`), KEY `idx_article_id` (`article_id`) ) ENGINE=InnoDB DEFAULT CHARSET=latin1 一条插入操作1insert into `t_articles` ('article_id', `sub_category_cn`) values (\"20180830012203\", \"海鸟和鱼相爱，只是一场意外。\"); 插入的结果可能有两种，一种是如下： article_id sub_category_cn 20180830012203 海鸟和鱼相爱，只是一x 另一种是直接报错，无法插入。 原因分析原因大概率是因为sub_category_cn字段类型是varchar，varchar(32)能存储32个字符，超过32个字符的部分会被截断，而如果连接采用了strict=true严格模式则插入会直接报错。那么问题来了： “海鸟和鱼相爱，只是一场意外。”这句话带上标点符号也没有超过32个字，为什么会被截断？海鸟和鱼相爱到底是不是意外？ 看看latin1 字符集对于数据的处理方式： ISO/IEC 8859-1:1998, Information technology — 8-bit single-byte coded graphic character sets 参考维基百科中对于这个标准的阐述可以明确，Latin1编码格式中，每个字符占8bit，也就是一个字节。而utf8编码规则也很简单： 1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。 2）对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。 Unicode符号范围 UTF-8编码方式 0000 0000-0000 007F 0xxxxxxx 0000 0080-0000 07FF 110xxxxx 10xxxxxx 0000 0800-0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 到这里，大概能猜到latin1作为连接字符集时 MySQLvarchar类型对于字符长度计算方式了. 验证1set names latin1; 告诉 MySQL 所有的 SQL 语句会以 latin1 字符集发送给服务端，请服务端按照 latin1 的方式进行解析。因此，当一个 UTF8 编码的汉字被发送过去时，实际上 MySQL 会把二进制的每8位当做一个字符来处理，而不是用 utf8 编码的方式去解析头八位看这个字符有几个字节。因此最终的结果是每个汉字会被当做3~4个字符来处理。 接下来做个简单的实验：123# 终端编码为utf8，连接字符集为 latin1set names latin1;select char_length(\"海鸟海鸟\"); result: 1234+------------------------+| char_length(&quot;海鸟海鸟&quot;) || 12 |+------------------------+ 采用 set names latin1 作为连接字符集，计算出来的UTF8编码的字符长度为 3*4=12。 123# 终端编码为utf8，连接字符集为 utf8set names latin1;select char_length(\"海鸟海鸟\"); result: 1234+------------------------+| char_length(&quot;海鸟海鸟&quot;) || 4 |+------------------------+ 采用 set names utf8; 作为连接字符集，计算出来的UTF8编码的字符长度为 4，符合预期。 总结 如果不用strict模式可能发现不了这个问题； 设计mysql表需要考虑的问题很多，字符集的选择就是一个很重要又很容易被忽视的点。 看起来latin1对于字符串存储可以说是万能的，因为它单字节处理的方式可以让多字节编码也可以被正常存入数据库。在近几年的工作实践中经常会遇到为了存储emoji表情需要改造数据表的字符集的情况，大多数方案都是改为utf8mb4这种字符编码，它是utf8的扩充，能兼容utf8。而实际上latin1也是可以存储emoji表情的，不知道有没有团队踩过坑？ 听说世界上有10种人，一种是懂二进制的，一种是不懂二进制的。 参考 维基百科:UTF-8 维基百科:ISO/IEC 8859-1 MySQL 5.7 Reference Manual: West European Character Sets MySQL 5.7 Reference Manual: The CHAR and VARCHAR Types 阮一峰的网络日志：字符编码笔记：ASCII，Unicode 和 UTF-8"},{"title":"为什么使用INT型数据查询varchar字段会导致全表扫描","permalink":"https://vividcoding.github.io/2018/05/15/why-using-an-integer-to-select-varchar-cause-a-full-table-scan/","text":"一个简单的查询语句引发的血案。 场景1select * form `db_articles`.`tbl_articles` where article_id=2018010100000 limit 1; DDL123456CREATE DATABASE `db_articles` /*!40100 DEFAULT CHARACTER SET latin1 */CREATE TABLE `tbl_articles` ( `article_id` varchar(14) NOT NULL DEFAULT '' PRIMARY KEY (`article_id`)) ENGINE=InnoDB DEFAULT CHARSET=latin1 查询的语句非常简单，但是却存在巨大的隐患，因为无法用到索引会导致执行查询语句需要扫描整张表的数据，如果这张表非常大的话会导致整个数据库服务器I/O被占满，接近宕机状态。 原因分析查询结果对吗？首先，这个场景下这条语句能否查出结果呢？不一定，这个完全需要在业务侧保证生成的article_id字段唯一，不然就会导致下面的情况：1234INSERT INTO `db_articles`.`tbl_articles` (`article_id`) VALUES ('20180515000000');INSERT INTO `db_articles`.`tbl_articles` (`article_id`) VALUES ('20180515000001');INSERT INTO `db_articles`.`tbl_articles` (`article_id`) VALUES ('020180051500');INSERT INTO `db_articles`.`tbl_articles` (`article_id`) VALUES ('20180051500'); 查询语句如下：12use db_articles;select * from tbl_articles where article_id=20180051500; 查询结果如下：| article_id || - || 020180051500 || 20180051500 | 可以看出，查询结果不一定是预期结果，这条查询的问题在于 where 条件里 article_id=20180051500, 而 mysql 认为 “020180051500” = 20180051500，因此查出了错误的结果。既然知道该字段类型是VARCHAR，那在查询的时候一定要保证 where 条件的值在程序中以字符串类型发送到数据库。 正确的查询：12345use db_articles;select * from tbl_articles_2 where article_id=\"20180051500\";select * from tbl_articles_2 where article_id=CONCAT(20180051500); 再来看一个官方提供的例子： 1234SELECT '18015376320243458' = 18015376320243458; -&gt; 1SELECT '18015376320243459' = 18015376320243459; -&gt; 0 上面这个例子我在自己装的MySQL版本上已经无法得到官方提供的结果，不过用下面的测试可以得出相似的结果：1234SELECT '999999999999999999999999999999999999999999999999999999999999999999999999999999999'=999999999999999999999999999999999999999999999999999999999999999999999999999999999 -&gt; 1SELECT '1000000000000000000000000000000000000000000000000000000000000000000000000000000000'=1000000000000000000000000000000000000000000000000000000000000000000000000000000000 -&gt; 0 上面第一句，81位数字，都是9，比较出来相等，但是+1之后就不等了。 问题原因MySQL文档中的解释：12.2 Type Conversion in Expression Evaluation If one or both arguments are NULL, the result of the comparison is NULL, except for the NULL-safe &lt;=&gt; equality comparison operator. For NULL &lt;=&gt; NULL, the result is true. No conversion is needed. If both arguments in a comparison operation are strings, they are compared as strings. If both arguments are integers, they are compared as integers. Hexadecimal values are treated as binary strings if not compared to a number. If one of the arguments is a TIMESTAMP or DATETIME column and the other argument is a constant, the constant is converted to a timestamp before the comparison is performed. This is done to be more ODBC-friendly. This is not done for the arguments to IN(). To be safe, always use complete datetime, date, or time strings when doing comparisons. For example, to achieve best results when using BETWEEN with date or time values, use CAST() to explicitly convert the values to the desired data type. A single-row subquery from a table or tables is not considered a constant. For example, if a subquery returns an integer to be compared to a DATETIME value, the comparison is done as two integers. The integer is not converted to a temporal value. To compare the operands as DATETIME values, use CAST() to explicitly convert the subquery value to DATETIME. If one of the arguments is a decimal value, comparison depends on the other argument. The arguments are compared as decimal values if the other argument is a decimal or integer value, or as floating-point values if the other argument is a floating-point value. In all other cases, the arguments are compared as floating-point (real) numbers. 两个参数至少有一个是 NULL 时，比较的结果也是 NULL，例外是使用 &lt;=&gt; 对两个 NULL 做比较时会返回 1，这两种情况都不需要做类型转换 两个参数都是字符串，会按照字符串来比较，不做类型转换 两个参数都是整数，按照整数来比较，不做类型转换 十六进制的值和非数字做比较时，会被当做二进制串，和数字做比较时会按下面的规则处理 有一个参数是 TIMESTAMP 或 DATETIME，并且另外一个参数是常量，常量会被转换为 timestamp 有一个参数是 decimal 类型，如果另外一个参数是 decimal 或者整数，会将整数转换为 decimal 后进行比较，如果另外一个参数是浮点数，则会把 decimal 转换为浮点数进行比较 所有其他情况下，两个参数都会被转换为浮点数再进行比较 再参考 8.3.1 How MySQL Uses Indexes中提到的： Comparison of dissimilar columns (comparing a string column to a temporal or numeric column, for example) may prevent use of indexes if values cannot be compared directly without conversion. For a given value such as 1 in the numeric column, it might compare equal to any number of values in the string column such as ‘1’, ‘ 1’, ‘00001’, or ‘01.e1’. This rules out use of any indexes for the string column. 如果做值的比较时需要根据上面的机制做类型转换的话，考虑到1可能等于’1’,’ 1’,’00001’甚至 ‘01.e1’,因此非常大的概率导致无法使用到索引。但是如果列类型是数字型，where条件是字符串的情况是可以用到索引的，因为字符串会被转换成数字，而数字之间比较会出现非确定结果的情况。 总结mysql 的隐式类型转换给使用者带来的方便可能伴随着非常沉重的代价，需要多加注意，尤其是随着业务发展，老业务DB需要变更字段类型（int转成varchar还是比较常见的)时需要非常慎重。"},{"title":"PHP7 FPM 启动源码分析<一>","permalink":"https://vividcoding.github.io/2017/05/26/PHP7-FPM-internels/","text":"从源码角度去分析 FPM 的启动步骤 PHP-FPM 启动分析PHP-FPM 的源代码在 php-src/sapi/fpm 目录中，因为 php 是用 C 语言写的，所以第一步就是找到 main() 函数。fpm_main.c 文件的 1571 行开始便是 main 函数的主体： 12345678910111213141516171819202122232425int main(int argc, char *argv[])&#123; int exit_status = FPM_EXIT_OK; int cgi = 0, c, use_extended_info = 0; zend_file_handle file_handle; /* temporary locals */ int orig_optind = php_optind; char *orig_optarg = php_optarg; int ini_entries_len = 0; int max_requests = 500; // 默认最大请求数 int requests = 0; int fcgi_fd = 0; fcgi_request *request; char *fpm_config = NULL; char *fpm_prefix = NULL; char *fpm_pid = NULL; int test_conf = 0; int force_daemon = -1; int force_stderr = 0; int php_information = 0; int php_allow_to_run_as_root = 0; ...&#125; 上面这段是 main 函数变量初始化部分的代码，这里主要关注 max_requests, requests, fcgi_fd , *request 这几个变量。 首先是 max\\_requests，配置过 php-fpm 的开发者都应该知道可以在配置文件中配置 pm.max_requests 的值，在文档中有详细的说明它的作用： 设置每个子进程重生之前服务的请求数。对于可能存在内存泄漏的第三方模块来说是非常有用的。如果设置为 ‘0’ 则一直接受请求，等同于 PHP_FCGI_MAX_REQUESTS 环境变量。默认值：0。 可以看到它的默认值是 500，按照文档中所描述的，如果处理的请求数达到 500 之后，会触发改进程的 “重生”，后面我们会介绍这个过程。 继续往下看： 1234567...zend_signal_startup();sapi_startup(&amp;cgi_sapi_module);cgi_sapi_module.php_ini_path_override = NULL;cgi_sapi_module.php_ini_ignore_cwd = 1;... 这一段主要是初始化 sapi 的代码，调用 sapi_startup 函数，传入 &amp;cgi_sapi_module。因为 fpm 实际上是一个 sapi 的 module, 而 sapi 的 module 是被定义好的一个数据结构，cgi_sapi_module 的初始化可以在 fpm_main.c 中找到： 12345678910111213141516171819202122232425262728293031static sapi_module_struct cgi_sapi_module = &#123; \"fpm-fcgi\", /* name */ \"FPM/FastCGI\", /* pretty name */ php_cgi_startup, /* startup */ php_module_shutdown_wrapper, /* shutdown */ sapi_cgi_activate, /* activate */ sapi_cgi_deactivate, /* deactivate */ sapi_cgibin_ub_write, /* unbuffered write */ sapi_cgibin_flush, /* flush */ NULL, /* get uid */ sapi_cgibin_getenv, /* getenv */ php_error, /* error handler */ NULL, /* header handler */ sapi_cgi_send_headers, /* send headers handler */ NULL, /* send header handler */ sapi_cgi_read_post, /* read POST data */ sapi_cgi_read_cookies, /* read Cookies */ sapi_cgi_register_variables, /* register server variables */ sapi_cgi_log_message, /* Log message */ NULL, /* Get request time */ NULL, /* Child terminate */ STANDARD_SAPI_MODULE_PROPERTIES&#125;; 可以看出 cgi_sapi_module 的数据类型是 sapi_module_struct，这个数据类型是 PHP 的 SAPI 中定义的，是类似于 OOP 中 class 的东西。而这个 sapi_startup 函数做的主要事情是分配互斥量(tsrm_mutex_alloc)。互斥量主要为针对多线程准备的，而 fastcgi 模式运行 PHP 都是单线程，所以不存在多线程中出现临界资源的使用问题。 在此之后的很长一部分代码都是处理命令行模式运行时的输入参数，这一段先略过，直接跳到 cgi_sapi_module 的 startup 部分： 1234567/* startup after we get the above ini override se we get things right */ if (cgi_sapi_module.startup(&amp;cgi_sapi_module) == FAILURE) &#123;#ifdef ZTS tsrm_shutdown();#endif return FPM_EXIT_SOFTWARE; &#125; 根据上面提到的 sapi_module_struct 的定义和 cgi_sapi_module 初始化的结果，不难看出 startup 调用的实际上是 fpm_main.c 中 php_cgi_startup 函数。而 php_cgi_startup 函数中主要做的事情就是调用 php 的 main.c 中定义的 php_module_startup 函数。像这种调用方式在 php 的实现中非常常见，保证了代码的鲁棒性。至于 php_module_startup 都干了哪些事情，后面再详细介绍，简而言之，该函数将会读取 php.ini 中的配置初始化 php 解释运行环境，主要包括： php 核心配置 zend 配置 php 扩展初始化及启动 1234567static int php_cgi_startup(sapi_module_struct *sapi_module) /* &#123;&#123;&#123; */&#123; if (php_module_startup(sapi_module, &amp;cgi_module_entry, 1) == FAILURE) &#123; return FAILURE; &#125; return SUCCESS;&#125; 到目前为止，需要的东西都初始化过了，该进入 fpm 的正题了： 12345678910111213141516171819202122232425262728293031if (0 &gt; fpm_init(argc, argv, fpm_config ? fpm_config : CGIG(fpm_config), fpm_prefix, fpm_pid, test_conf, php_allow_to_run_as_root, force_daemon, force_stderr)) &#123; if (fpm_globals.send_config_pipe[1]) &#123; int writeval = 0; zlog(ZLOG_DEBUG, \"Sending \\\"0\\\" (error) to parent via fd=%d\", fpm_globals.send_config_pipe[1]); zend_quiet_write(fpm_globals.send_config_pipe[1], &amp;writeval, sizeof(writeval)); close(fpm_globals.send_config_pipe[1]); &#125; return FPM_EXIT_CONFIG; &#125; if (fpm_globals.send_config_pipe[1]) &#123; int writeval = 1; zlog(ZLOG_DEBUG, \"Sending \\\"1\\\" (OK) to parent via fd=%d\", fpm_globals.send_config_pipe[1]); zend_quiet_write(fpm_globals.send_config_pipe[1], &amp;writeval, sizeof(writeval)); close(fpm_globals.send_config_pipe[1]); &#125; fpm_is_running = 1; fcgi_fd = fpm_run(&amp;max_requests); parent = 0; /* onced forked tell zlog to also send messages through sapi_cgi_log_fastcgi() */ zlog_set_external_logger(sapi_cgi_log_fastcgi); /* make php call us to get _ENV vars */ php_php_import_environment_variables = php_import_environment_variables; php_import_environment_variables = cgi_php_import_environment_variables; /* library is already initialized, now init our request */ request = fpm_init_request(fcgi_fd); 首先便是 fpm_init，然后是 fpm_run，最后是 fpm_init_request。 12345678910111213141516171819202122232425262728293031323334353637383940414243int fpm_init(int argc, char **argv, char *config, char *prefix, char *pid, int test_conf, int run_as_root, int force_daemon, int force_stderr) /* &#123;&#123;&#123; */&#123; fpm_globals.argc = argc; fpm_globals.argv = argv; if (config &amp;&amp; *config) &#123; fpm_globals.config = strdup(config); &#125; fpm_globals.prefix = prefix; fpm_globals.pid = pid; fpm_globals.run_as_root = run_as_root; fpm_globals.force_stderr = force_stderr; if (0 &gt; fpm_php_init_main() || 0 &gt; fpm_stdio_init_main() || 0 &gt; fpm_conf_init_main(test_conf, force_daemon) || 0 &gt; fpm_unix_init_main() || 0 &gt; fpm_scoreboard_init_main() || 0 &gt; fpm_pctl_init_main() || 0 &gt; fpm_env_init_main() || 0 &gt; fpm_signals_init_main() || 0 &gt; fpm_children_init_main() || 0 &gt; fpm_sockets_init_main() || 0 &gt; fpm_worker_pool_init_main() || 0 &gt; fpm_event_init_main()) &#123; if (fpm_globals.test_successful) &#123; exit(FPM_EXIT_OK); &#125; else &#123; zlog(ZLOG_ERROR, \"FPM initialization failed\"); return -1; &#125; &#125; if (0 &gt; fpm_conf_write_pid()) &#123; zlog(ZLOG_ERROR, \"FPM initialization failed\"); return -1; &#125; fpm_stdio_init_final(); zlog(ZLOG_NOTICE, \"fpm is running, pid %d\", (int) fpm_globals.parent_pid); return 0;&#125; 不难看出，fpm_init 返回 -1 时，整个程序将会退出，当有错误发生但是 fpm_globals 中标记了 test_successful 时，会使用 exit(0) 退出，因为配置文件没有错误，而成功时会返回 0。 fpm 初始化的过程分 13 步，分别是: fpm_php_init_main() 注册进程清理方法 fpm_stdio_init_main() 验证 /dev/null 是否可读写 fpm_conf_init_main(test_conf, force_daemon) 校验并加载配置文件 fpm_unix_init_main() 检查 unix 运行环境 fpm_scoreboard_init_main() 初始化“进程记分牌” fpm_pctl_init_main() 进程管理相关初始化 fpm_env_init_main() ？ fpm_signals_init_main() 设置信号处理方式 fpm_children_init_main() 初始化子进程，注册进程清理方法 fpm_sockets_init_main() 初始化 sockets fpm_worker_pool_init_main() 注册 worker pool 清理方法 fpm_event_init_main() 注册 event 清理方法 可以说相当复杂的一个过程，只要有一个函数无法返回 0，程序将直接退出。在完成这一系列的操作之后，fpm 会向配置文件中指定的 pid 文件写入 master 进程id。整个过程其实是为了启动 php-fpm 进程做初始化的工作，到这一步 php-fpm 还是无法接收请求的。 1234if (0 &gt; fpm_conf_write_pid()) &#123; zlog(ZLOG_ERROR, \"FPM initialization failed\"); return -1;&#125;"},{"title":"按分组选出值最大的n行数据","permalink":"https://vividcoding.github.io/2017/05/18/select-max-top-n-rows-with-groupby/","text":"介绍几种选出值最大的n行数据的方法 描述有一张表，结构如下：id为自增主键，innodb 引擎 id（PK,AI) product_id product_name product_price shop_id（FK) 1000 23134 ‘bread’ 2.30 13421 1001 23135 ‘beaf’ 7.30 13421 1002 23154 ‘apple’ 3.30 13421 1003 39134 ‘rice’ 1.30 13422 1004 73234 ‘chicken’ 4.30 13422 1005 832134 ‘orange’ 2.50 13422 1006 75139 ‘banana’ 6.30 13423 1007 52128 ‘melon’ 1.20 13423 1008 21114 ‘strawberry’ 4.90 13423 DDL 如下：123456789CREATE TABLE `product` ( `id` int(11) NOT NULL AUTO_INCREMENT, `product_id` bigint(20) NOT NULL, `product_name` varchar(255) DEFAULT '', `product_price` float DEFAULT NULL, `shop_id` bigint(20) DEFAULT NULL, PRIMARY KEY (`id`), KEY `index2` (`product_id`,`shop_id`,`product_price`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8; 测试数据：12345678910INSERT INTO test.product (product_id, product_name, product_price, shop_id) VALUES (29, 'prod_1.2', 1.2, 100);INSERT INTO test.product (product_id, product_name, product_price, shop_id) VALUES (12, 'prod_2.2', 2.2, 100);INSERT INTO test.product (product_id, product_name, product_price, shop_id) VALUES (14, 'prod_200_1.5', 1.5, 200);INSERT INTO test.product (product_id, product_name, product_price, shop_id) VALUES (15, 'prod_200_11.5', 11.5, 200);INSERT INTO test.product (product_id, product_name, product_price, shop_id) VALUES (16, 'prod_200_12.3', 12.3, 200);INSERT INTO test.product (product_id, product_name, product_price, shop_id) VALUES (17, 'prod_300_220.1', 220.1, 300);INSERT INTO test.product (product_id, product_name, product_price, shop_id) VALUES (18, 'prod_300_100.2', 100.2, 300);INSERT INTO test.product (product_id, product_name, product_price, shop_id) VALUES (19, 'prod_300_300', 300, 300);INSERT INTO test.product (product_id, product_name, product_price, shop_id) VALUES (21, 'prod_100_120', 120, 100);INSERT INTO test.product (product_id, product_name, product_price, shop_id) VALUES (91, 'prod_400_1.2', 1.2, 400); 第一个问题：查出每个店铺价格最贵的商品这个问题非常简单，因为 MySQL 有一个 Max 函数可以计算出最大的值，并按照 shop_id group 即可：12345SELECT product_id, product_name, shop_id, MAX(product_price)FROM productGROUP BY shop_id; 要是真这么以为的话，那就要铸成大错了！这里有一个误区，MAX 函数和 group by 配合使用确实能计算出每个商店最贵的商品，但是其他列的数据理论上是和这个最大值无关的，如果结果正确了，一定是因为巧合！ 说到这里，就顺带记录一下一条查询（select）语句中各个关键字执行的顺序：12345678910(8) SELECT (9) DISTINCT&lt;select_list&gt;(1) FROM &lt;left_table&gt;(3) &lt;join_type&gt; JOIN &lt;right_table&gt;(2) ON &lt;join_condition&gt;(4) WHERE &lt;where_condition&gt;(5) GROUP BY &lt;group_by_list&gt;(6) WITH(7) HAVING(10) ORDER BY &lt;order_by&gt;(11) LIMIT GROUP BY 是先于 SELECT 执行的，而 MAX 函数会根据 GROUP BY 的条件去对结果进行聚合计算出按照该列分类的每一类中的最大值，其他列与这个值并不具备相关性，也无法做到相关性。所以上面那个是错误的。 一种思路是这样的：先将 shop_id 和 max(product_price) 选出来，再根据结果与表自身做一次连接，连接条件就是 shop_id 和 product_price。SQL 如下，123456789101112SELECT p2.*FROM (SELECT shop_id, MAX(product_price) AS product_price FROM product p1 GROUP BY shop_id) AS p1 INNER JOIN product p2 ON p2.shop_id = p1.shop_id AND p2.product_price = p1.product_priceORDER BY p2.id; 还有一种思路是：使用关联子查询，这种方式比上一种的效率要高很多，子查询将每个商店的最大值取出来，放入主查询的 where 条件，SQL 如下，1234567891011SELECT *FROM productWHERE product_price IN (SELECT MAX(product_price) FROM product GROUP BY shop_id)ORDER BY id; 很显然第二种方式的查询效率更高，至于怎么建立索引，我这里选取了 shop_id 和 product_price 两个字段建立BTREE联合索引，而索引选择的原则我现在还不是很有经验，只是凭直觉，从 EXPLAIN 的结果上看的话，还是不错的。 第二个问题：每个店铺价格最贵的 2 件商品看到这个题目，我第一反应是，要按照每个店铺去聚集计算出最大的两行，然后再使用 union join 把所有结果合并起来，显然这种做法缺乏灵活性，如果我有一千个商铺，那岂不是要有999个 union join…ヽ(*。&gt;Д&lt;)o゜可怕！ 上面第一题中使用 product_price 与子查询做连接查出最贵的，同样可以查出第二贵的商品，具体实现 SQL 如下， 解法 112345678910111213141516171819SELECT *FROM `product` p1WHERE `product_price` = (SELECT MAX(`product_price`) FROM `product` p2 WHERE `p2`.`shop_id` = `p1`.`shop_id`) OR `product_price` = (SELECT MAX(`product_price`) FROM `product` p3 WHERE `p3`.shop_id = `p1`.shop_id AND `p3`.`product_price` &lt; (SELECT MAX(product_price) FROM `product` p4 WHERE `p4`.`shop_id` = `p3`.`shop_id`) GROUP BY p3.shop_id) 结构还是很清晰的，先查出最高的和第二高的，不过这种解法并不是很优雅： 一共使用了三个 DEPENDENCY SUBQUERY，可以说是非常复杂的。而且当需求一变，这个 SQL 就无效了，我个人认为使用频次高的查询要尽量具有通用性，这样在性能优化的时候也具有更大的操作空间。 TOP N 条记录，用子查询怎么解决？ 解法 2-112345678910111213SELECT `p1`.*FROM `product` p1WHERE 2 &gt; (SELECT COUNT(*) FROM `product` p2 WHERE `p2`.`shop_id` = `p1`.`shop_id` AND `p2`.`product_price` &gt; `p1`.`product_price`)ORDER BY `p1`.`shop_id` , `p1`.`product_price` DESC; 上述解法的核心理念是用一个关联子查询查出 product_price 列的所有值中，值比其大的行总数小于2(或者n)的所有行，子查询与表达式作为 where 条件返回 TRUE 或者 FALSE，最后返回的是返回 TRUE 的所有行。 更通俗一点解释，要查最大的两行，遍历到其中一行的时候，将其和表中每一行对应的列的值做一一比较，总数小于2的话，那说明它是最大的两个值之一，所以就命中选择条件。 这种思路还可以这么写，使用 HAVING 来控制 TRUE/FALSE 解法 2-21234567891011121314SELECT `p1`.*FROM `test`.`product` p1WHERE EXISTS( SELECT COUNT(*) FROM `test`.`product` p2 WHERE `p2`.`shop_id` = `p1`.`shop_id` AND `p2`.`product_price` &gt; `p1`.`product_price` HAVING COUNT(*) &lt; 2)ORDER BY `p1`.`shop_id`, `p1`.`product_price` DESC;"},{"title":"HTTP POST 表单提交方式介绍","permalink":"https://vividcoding.github.io/2017/05/17/http-post-methods-comparison/","text":"为客户端提供接口的时候，发现客户端对于 http 接口的调用方式不是很清楚，介绍 HTTP POST 请求的几种常用的 Content-Type。HTTP 1.1 RFC-2616 协议中 Content-Type 的定义是： The Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET. 它被放置在 header 中，表示发送的请求 Body 中的数据格式。 multipart/form-datamultipart/form-data 在 web 领域经常被用于表单提交，被提交的数据一般是一个完整的 Model，例如登录注册的表单的场景。 application/octet-streamx-www-form-urlencodedrawbinary"},{"title":"2017 面试记录","permalink":"https://vividcoding.github.io/2017/05/17/2017-interviews/","text":"找工作呀找工作… 今日头条头条工作环境确实不错，约的上午10点半，前台安排到一个面试间，然后等了大概20分钟左右面试官来了，看起来挺技术范儿的一哥们儿。 一面一面主要讲了一些项目上的经历，让挑一个自己觉得不错的项目讲了一下，挑的是在微博做的一个项目，然后里面因为提到做了一些性能优化的事情，就深入问了一些数据库优化方面的知识，结合一些具体的应用场景，比如大的报表导出的性能优化方向，主要就是一些索引的选择、联表查询的优化上。然后问了一下B+树和SQL执行的过程，没好好准备，答的比较粗。 然后就是另外一个并发量比较高的项目，介绍了整个性能优化的过程，这一块因为是去年底刚刚做的，所以记忆还比较深刻。在提到opcache的时候顺带把自己写的opcache源码分析给面试官看了一下，应该印象还不错，面试官也发表了一些自己的看法。然后他对我们使用PHP7还比较惊讶。 最后面试官让写了一道算法题，两个有序数组的合并。刚开始有点紧张，不过后来在纸上写出来了，常考不难的题目。 redis+mysql 的数据一致性问题怎么解决 B+树 SQL 执行过程 数据库性能优化 对 MVC 分层的理解，对设计模式的使用 二面二面的面试官好像不太看我的简历上的东西了，主要出了下面几个题目： 手写SQL, 查询每个店铺最贵的N个商品，降序排列 MySQL 性能优化的方法，涉及 SQL 执行过程分析，Explain 结果分析，还出了个SQL语句问有没有用到索引 算法题：全排列，用递归写了，然后要求用非递归实现 数据库的四种隔离级别 数据库锁的原理，SELECT … FOR UPDATE 和 SELECT … 的区别，上的什么锁，锁之间的互斥关系 varchar(50) int(4) char(50) 里面数字分别的含义 解释脏读、幻读 PHP 生命周期 Top 命令各项数据的解释 socket 建立连接每一步的客户端和服务端状态 syn 泛洪攻击 opcache 缓存过期策略 redis 的事务 通过头条这次面试还是能发现很多薄弱环节，对一些知识的理解浮于表面，没有深入去细看，所以导致有些问题答的比较犹豫、粗，接下来还是认真去怼一些应该知道的东西的细节，不能太浮躁，知识积累是很漫长的过程，像数据库的一些细节是需要深入了解细节才能加深理解的，实际使用的过程中虽然看起来没有遇到问题，但是只要流量大了，很多细节不注意就会被放大到影响业务的正常运转。 另外一个问题是自己的表达能力还是很欠缺的，很多问题我其实想的挺清楚，但是表达起来语言组织能力感觉很差，容易让面试官听不懂，不知道是不是太紧张的原因。 美图美图北京在搜狐网络大厦，不错的写字楼，高峰期电梯也没有特别的多人。 笔试题笔试题比较少，就5道题 观察者模式（对象属性变化通知） global 的使用 缓存被击穿了，怎么办 设计日志收集系统 设计大型文章推荐系统架构 面试问题 PSR4 与 PSR0 区别 autoload 和 spl_autoload 的区别 面经聊的基本都是上面的问题，问题也比较开放，我自己还是老问题依然存在：知识点没吃透。具体一点的话，对设计模式的理解和运用还不熟练，对于缓存和落地之间的配合和紧急故障处理的方式上回答的也不够果断和富有经验。不过面试官也比较直白的说了我还是缺乏大型项目经验，再加上我的期望薪资写的比较高，确实是很高，不过我心里是给他们砍价的空间的，连砍价都不砍，那估计是真的太高了吧。一面挂，没啥更多的可以说，认真结合自己的情况和职业发展的期望分析，还是希望接下来能够有机会去 BAT 这种平台多磨练两年。继续加油吧！"},{"title":"OPCache 工作机制","permalink":"https://vividcoding.github.io/2016/12/18/things-about-opcache/","text":"基于 PHP7 源码分析 opcache 内部工作机制 一个请求的 np (Nginx - PHP) 之旅 Nginx 监听 80 端口，接到请求后，通过 socket 将请求发到其 worker 上； Worker 根据 Nginx 配置再将请求发到 php-fpm 管理的的进程池中； php-fpm 根据请求调用 php-cgi 执行 php 脚本； 执行完的结果会被返回给 nginx。 因为本文主要是讲 php 执行过程中 opcache 的作用，所以上面四个步骤暂时只需要关注第3点。 两个概念php-fpm全称：php-fastcgi process manager, 主要干几件事 管理 php-cgi 进程 管理 php-cgi 进程 管理 php-cgi 进程 php-cgi全称：php-cgi, php 有两种运行方式，cli 和 cgi, cli 就是命令行执行 1/usr/local/bin/php -f a.php cgi 就是所谓的 Common Gateway Interface（通用网关接口），详细可以去翻一下 《HTTP 权威指南》，php-cgi 就是用于提供给网站的 php 解释器。 一次完整的脚本执行过程这是一个标准的脚本语言干的事情： 词法分析 + 语法分析 =&gt; 生成语法树 通过语法树 =&gt; 生成操作码 按操作码的顺序一步一步执行 输出结果 每次请求过来php都会通过如上四步来处理请求，每次都是。但是实际业务运转中，很多流程其实是完全一样的，甚至连变量的值都一样，然而，解释编译过程仍然会去读取相同的代码来一遍，不禁想起一句话： 越是简单重复的工作越能体现出制作者的心意 能更快的把客户需要的东西送到他们手上也很重要！毫无疑问，这个过程中存在对资源的极大浪费，我们都知道词法的分析和解释以及编译都是极其消耗计算资源的过程，于是乎，用于缓存 OPCodes 的扩展应运而生。它只有一个目标，每个 PHP 脚本只被编译一次，然后将生成的 OPCodes 存储到共享内存区中，如此，其他的 php-fpm 进程都可以访问并使用共享缓存区中的 OPCodes。 这个方法能给 PHP 脚本的执行速度提升两倍以上！实际运用中，对于 include 几十几百个脚本的大型网站，其速度提升会超过 10 倍，这是因为 PHP 的编译器很慢，因为它需要将一堆具有语义的编程语言转换成机器能执行的操作码，尝试去理解产品经理的需求，并且要在保证安全和正确的前提下尽量生成流程最优的操作码序列。 PHP 中用于缓存 OPCodes 的扩展主要有： APC XCache Eaccelerator OPCache（Zend Optimizer+) … APC 可能很多 PHP 程序员用过或者正在用，但是 APC 已经不再更新很久了，如果可以，升级到 PHP7 吧！为了世界和平！ 更详细的信息可以在 Wikipedia:List of PHP accelerators 找到，这里就不做对比了，本文主要研究 OPCache。 OPCache 简介opcache 原称：Zend Optimizer+ ，是 Zend Server 的一个开源组件，在2013年3月中旬之后更名为 Zend Opcache。它从 PHP 5.5 开始就随着 PHP 一起发行，但是必须要在 php.ini 中打开才可以生效，它主要提供两个优化方向： OPCodes 和 Interned Strings 的缓存（用于进程间共享） OPCodes 优化 OPCache 触发 PHP 编译器启动，获取 OPCodes 然后将其缓存起来，所以在这个过程中同样可以做另外一件事：代码优化。 OPCodes 和 Interned Strings 的缓存让我们深入研究一下 opcache 的工作原理, 它的源代码在这里： php-src/ext/opcache 共享内存模型前面提到了缓存的机制主要是将编译好的操作码放入共享内存提供给其他进程访问，UNIX 系统提供很多种进程间内存共享的方式，常用的有： System-V shm API POSIX API mmap API OPCache 会根据系统支持的情况选择合适的接口 12345678910111213141516// 选择共享内存模型static const zend_shared_memory_handler_entry handler_table[] = &#123;#ifdef USE_MMAP &#123; \"mmap\", &amp;zend_alloc_mmap_handlers &#125;,#endif#ifdef USE_SHM &#123; \"shm\", &amp;zend_alloc_shm_handlers &#125;,#endif#ifdef USE_SHM_OPEN &#123; \"posix\", &amp;zend_alloc_posix_handlers &#125;,#endif#ifdef ZEND_WIN32 &#123; \"win32\", &amp;zend_alloc_win32_handlers &#125;,#endif &#123; NULL, NULL&#125;&#125;; 这个配置项可用于配置首选共享内存模型，如果没有设置这个值，OPCache 会选择系统第一个可以使用的模型。 opcache.preferred_memory_model // 用于设置首选共享内存模型 OPCache 默认会使用的是 mmap, 它是一种很常见的内存模型, 详细可以参考 《UNIX 环境高级编程》。 在 OPCache 启动之后，它会从系统中申请一块内存用作共享内存，大小取决于 php.ini 中 opcache.memory_consumption 配置的内存大小，它只会申请一次，不会释放，不会碎片化 （稍后会提到为什么），建议配置 opcache.memory_consumption 时不要吝啬，因为对于 PHP 实现的 网站来说，应该绝大多数不需要超过 1GB 内存。OPCache 申请这些内存用来存放下列内容和数据： 脚本数据结构，包含且不限于 OPCode 的缓存 Interned Strings 脚本的哈希表 全局 OPCache 共享内存的状态 … 也就是说，这部分内存不仅仅用于存储可复用的操作码序列，而且会有一些 OPCache 自身需要的东西在里面， 并且每部分占用的比例是可以设置的。 先分别来看一下 OPCodes 缓存和 Interned Strings 共享： OPCodes 缓存(操作码缓存)文章刚开始的时候介绍了 Nginx 监听 80 端口，接到请求后，通过 socket 将请求发到其 worker 上，而这个 worker 就是 php-fpm 的子进程，每个请求都对应一个 php-fpm 进程，看一下请求一个包含 FPM 简要启动过程的请求执行流程图（到 zend_compile_file())： 简单解释一下这个过程，当用户启动 php-fpm 的时候，它会根据配置初始化各种依赖，准备好各种资源，然后根据配置启动一定数量的子进程，这些子进程就是用于处理请求的，主进程本身不处理请求，主进程只需要负责根据配置统一初始化好进程资源（包括 PHP 编译执行环境），fork() 出子进程出来，进入等待状态，一旦有请求进来，php-fpm 进程就会进入 php 脚本的执行过程。 从图中可以看出，当 php-fpm 启动的时候，会将 php 的环境准备好再接受请求，所以，当 php.ini 文件中打开了 opcache 扩展的情况下，执行 php 脚本开始前 opcache 扩展已经启动了。 下面就详细介绍 opcache 扩展启动的过程已经工作原理： 所有本文中所介绍的东西都基于一个基本法：将处理每个请求过程中作用相同的指针以及不会发生变化的内容全部存入共享内存。 针对相同的请求，PHP 编译器将从共享内存中直接取出编译好的操作码序列（op_array），绑定到当前处理该请求的 php-fpm 子进程中。PHP 编译器工作的时使用 Zend Memory Manager(ZMM) 来分配指针。 这种内存使用方式是和请求绑定的，每次请求结束之后 ZMM 会主动释放这些内存空间。很显然这些被分配的指针地址是在当前进程的堆栈中，并且不可以被其他进程所共享的。因此 OPCache 的工作就是把每个 PHP 编译器返回的数据结构都检查一遍，然后把他们都拷贝到一个共享存储区中。 这里提到的编译过程中所有被编译器所处理的东西都是不可变的，也就是”常量”。可变的数据会在运行时由 Zend Virtual Machine 创建，所以我们认为保存所有被编译器所处理过的数据到共享内存中都是安全的，因为它们不会再将来发生变化。 这些被保存的东西包括：函数、类、函数的指针、函数的操作码数组指针、类的常量，类中被声明的变量名和它们最终的默认值等等，后面将会详细介绍。 这样的内存模型是为了在最大程度上避免出现资源锁，后文中将会详细介绍锁的相关内容。有一个很基本的 OPCache 只在运行之前工作一次，而在运行过程中，OPCache 则是个安静的美男子：ZMM 会在进程的堆栈中 创建变量，而常量则直接从 OPCache 提供的共享内存中取。 那 OPCache 怎么做到这一点呢？它其实是通过钩子的方式将自己注入到编译器中，替代编译 PHP 脚本 过程中需要填充的数据结构，让编译器初始化一个 persistent_script 的结构并且赋值来替代 Zend Engine 表和其他内部结构。 下面是 persistent_script 的结构定义： 1234567891011121314151617181920212223242526272829typedef struct _zend_persistent_script &#123; ulong hash_value; char *full_path; /* 绝对连接，并且软连接也是被解析过了 */ unsigned int full_path_len; zend_op_array main_op_array; /* opcode array ，操作码序列 */ HashTable function_table; HashTable class_table; long compiler_halt_offset; /* position of __HALT_COMPILER or -1 */ int ping_auto_globals_mask; /* which autoglobals are used by the script */ accel_time_t timestamp; /* 脚本修改时间戳 */ zend_bool corrupted; /* 是否过期 */#if ZEND_EXTENSION_API_NO &lt; PHP_5_3_X_API_NO zend_uint early_binding; /* the linked list of delayed declarations */#endif void *mem; /* shared memory area used by script structures */ size_t size; /* size of used shared memory */ /* All entries that shouldn't be counted in the ADLER32 * checksum must be declared in this struct */ struct zend_persistent_script_dynamic_members &#123; time_t last_used; ulong hits; unsigned int memory_consumption; unsigned int checksum; time_t revalidate; &#125; dynamic_members;&#125; zend_persistent_script; 当服务器第一次接到请求时，共享内存中是没有任何东西的，这时候 zend_accel_hash_str_find 肯定取不到任何东西，所以需要按照 OPCache 需要的配置去调用编译器编译出一份 persistent_script 结构，然后调用 cache_script_in_shared_memory 将这份数据结构存入共享内存中，并且继续将这个指针传给 zend_accel_load_script 函数设置覆盖CG, EG等全局变量中对应的一些值，这种机制保证了这个扩展设计的初衷：每个 PHP 脚本只被编译一次。 下面这段代码展示的是 OPCache 将编译器结构替换成 persistent_script 的过程： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/* 替代 zend_compile_file 函数 */static int accel_startup(zend_extension *extension)&#123; ... accelerator_orig_compile_file = zend_compile_file; zend_compile_file = persistent_compile_file; ...&#125;...zend_op_array *persistent_compile_file(zend_file_handle *file_handle, int type)&#123; ... if (!ZCG(accel_directives).revalidate_path) &#123; /* 用与脚本一一对应的 key 在共享内存中查找缓存 */ key = accel_make_persistent_key(file_handle-&gt;filename, strlen(file_handle-&gt;filename), &amp;key_length); if (!key) &#123; return accelerator_orig_compile_file(file_handle, type); &#125; persistent_script = zend_accel_hash_str_find(&amp;ZCSG(hash), key, key_length); //从共享内存中取出 persistent_script &#125; ... if (!persistent_script) &#123; from_shared_memory = 0; //如果缓存中没有, 调用 opcache_compile_file 进行初始化 persistent_script = opcache_compile_file(file_handle, type, key, key ? key_length : 0, &amp;op_array); if (persistent_script) &#123; // 初始化成功，调用 cache_script_in_shared_memory 写入共享内存 persistent_script = cache_script_in_shared_memory(persistent_script, key, key ? key_length : 0, &amp;from_shared_memory); &#125; if (!persistent_script) &#123; SHM_PROTECT(); return op_array; &#125; ... &#125;... // 这里将从 共享内存/文件缓存（php7）中拿到的 persistent_script 拷贝到处理请求的进程内存中 return zend_accel_load_script(persistent_script, from_shared_memory); ...&#125;...// 初始化一个 persistent_scriptstatic zend_persistent_script *opcache_compile_file(zend_file_handle *file_handle, int type, char *key, zend_op_array **op_array_p)&#123;...new_persistent_script = create_persistent_script();/* 保存一份原值 */orig_active_op_array = CG(active_op_array);orig_function_table = CG(function_table);orig_class_table = CG(class_table);ZVAL_COPY_VALUE(&amp;orig_user_error_handler, &amp;EG(user_error_handler));/* 用新的结构替换 */CG(function_table) = &amp;ZCG(function_table);EG(class_table) = CG(class_table) = &amp;new_persistent_script-&gt;class_table;ZVAL_UNDEF(&amp;EG(user_error_handler)); zend_try &#123; orig_compiler_options = CG(compiler_options); CG(compiler_options) |= ZEND_COMPILE_HANDLE_OP_ARRAY; CG(compiler_options) |= ZEND_COMPILE_IGNORE_INTERNAL_CLASSES; CG(compiler_options) |= ZEND_COMPILE_DELAYED_BINDING; CG(compiler_options) |= ZEND_COMPILE_NO_CONSTANT_SUBSTITUTION; op_array = *op_array_p = accelerator_orig_compile_file(file_handle, type); CG(compiler_options) = orig_compiler_options; &#125; zend_catch &#123; op_array = NULL; do_bailout = 1; CG(compiler_options) = orig_compiler_options; &#125; zend_end_try(); /* Restore originals */ CG(active_op_array) = orig_active_op_array; CG(function_table) = orig_function_table; EG(class_table) = CG(class_table) = orig_class_table; EG(user_error_handler) = orig_user_error_handler;...&#125;//end of *opcache_compile_file 从代码中可以看出，在 OPCache 插件初始化函数 accel_startup 中，默认编译器 zend_compile_file 被替换成了 persistent_compile_file，而 persistent_compile_file 中如果从共享内存中拿不到 persistent_script(还有其他原因，比如过期等) 则会调用 opcache_compile_file 重新编译一份新的 persistent_script，并把得到的结果保存到共享内存中提供给其他的进程使用。 上面这段代码中，有四个编译选项被设置，分别是 ZEND_COMPILE_HANDLE_OP_ARRAY 启用 zend_extension_op_array_handler 1234567...if (CG(compiler_options) &amp; ZEND_COMPILE_HANDLE_OP_ARRAY) &#123; if (zend_extension_flags &amp; ZEND_EXTENSIONS_HAVE_OP_ARRAY_HANDLER) &#123; zend_llist_apply_with_argument(&amp;zend_extensions, (llist_apply_with_arg_func_t) zend_extension_op_array_handler, op_array); &#125;&#125;... ZEND_COMPILE_IGNORE_INTERNAL_CLASSES 忽略内部类 ZEND_COMPILE_DELAYED_BINDING 延迟绑定 12345678910111213141516if (((ce = zend_lookup_class_ex(Z_STR_P(parent_name), parent_name + 1, 0)) == NULL) || ((CG(compiler_options) &amp; ZEND_COMPILE_IGNORE_INTERNAL_CLASSES) &amp;&amp; (ce-&gt;type == ZEND_INTERNAL_CLASS))) &#123; if (CG(compiler_options) &amp; ZEND_COMPILE_DELAYED_BINDING) &#123; uint32_t *opline_num = &amp;CG(active_op_array)-&gt;early_binding; while (*opline_num != (uint32_t)-1) &#123; opline_num = &amp;CG(active_op_array)-&gt;opcodes[*opline_num].result.opline_num; &#125; *opline_num = opline - CG(active_op_array)-&gt;opcodes; opline-&gt;opcode = ZEND_DECLARE_INHERITED_CLASS_DELAYED; opline-&gt;result_type = IS_UNUSED; opline-&gt;result.opline_num = -1; &#125; return; &#125; ZEND_COMPILE_NO_CONSTANT_SUBSTITUTION 在编译阶段禁用常量代替 1234567891011121314151617181920212223if (c &amp;&amp; ( ((c-&gt;flags &amp; CONST_PERSISTENT) &amp;&amp; !(CG(compiler_options) &amp; ZEND_COMPILE_NO_PERSISTENT_CONSTANT_SUBSTITUTION)) || (Z_TYPE(c-&gt;value) &lt; IS_OBJECT &amp;&amp; !(CG(compiler_options) &amp; ZEND_COMPILE_NO_CONSTANT_SUBSTITUTION)) )) &#123; ZVAL_DUP(zv, &amp;c-&gt;value); return 1; &#125; &#123; /* Substitute true, false and null (including unqualified usage in namespaces) */ const char *lookup_name = ZSTR_VAL(name); size_t lookup_len = ZSTR_LEN(name); if (!is_fully_qualified) &#123; zend_get_unqualified_name(name, &amp;lookup_name, &amp;lookup_len); &#125; c = zend_lookup_reserved_const(lookup_name, lookup_len); if (c) &#123; ZVAL_DUP(zv, &amp;c-&gt;value); return 1; &#125; &#125; 这几个选项主要是为了告诉编译器少做点无用功，让 OPCache 只做它能做和该做的事情。 OPCache 关注下面几种数据结构： 脚本中的函数 CG(function_table); 脚本中的类 CG(class_table); 脚本的 OPArray CG(active_op_array) 脚本的文件路径 脚本内容本身 OPCache 在内存管理上非常聪明，它知道它该做的事情是什么：尽量快的读写缓存。所以它不会释放内存，过期的内容占用的地址空间会被置为 wasted , 这中设计最大化的减少了内存碎片的产生，每当达到设置的内存使用上限时，会触发一次 重启，相比较花大量的精力去管理内存空间，却只是为了应付大量的 http 短连接，一次简单的重启更实用。 上面提到的缓存的第一步是计算数据大小，下面是它的实现： 123456789101112131415161718192021222324252627282930313233343536373839uint zend_accel_script_persist_calc(zend_persistent_script *new_persistent_script, char *key, unsigned int key_length)&#123; new_persistent_script-&gt;mem = NULL; new_persistent_script-&gt;size = 0; new_persistent_script-&gt;arena_mem = NULL; new_persistent_script-&gt;arena_size = 0; new_persistent_script-&gt;corrupted = 0; ZCG(current_persistent_script) = new_persistent_script; ADD_DUP_SIZE(new_persistent_script, sizeof(zend_persistent_script)); if (key) &#123;`` ADD_DUP_SIZE(key, key_length + 1); &#125; else &#123; /* script is not going to be saved in SHM */ new_persistent_script-&gt;corrupted = 1; &#125; ADD_STRING(new_persistent_script-&gt;full_path);#ifdef __SSE2__ /* Align size to 64-byte boundary */ new_persistent_script-&gt;size = (new_persistent_script-&gt;size + 63) &amp; ~63;#endif zend_accel_persist_class_table_calc(&amp;new_persistent_script-&gt;class_table); zend_hash_persist_calc(&amp;new_persistent_script-&gt;function_table, zend_persist_op_array_calc); zend_persist_op_array_calc_ex(&amp;new_persistent_script-&gt;main_op_array);#ifdef __SSE2__ /* Align size to 64-byte boundary */ new_persistent_script-&gt;arena_size = (new_persistent_script-&gt;arena_size + 63) &amp; ~63;#endif new_persistent_script-&gt;size += new_persistent_script-&gt;arena_size; new_persistent_script-&gt;corrupted = 0; ZCG(current_persistent_script) = NULL; return new_persistent_script-&gt;size;&#125; 从上面计算地址空间大小的实现就看出我们缓存的内容是： 脚本中的函数 &amp;new_persistent_script-&gt;function_table 脚本中的类 &amp;new_persistent_script-&gt;class_table 脚本的 OPArray &amp;new_persistent_script-&gt;main_op_array 脚本的文件路径 new_persistent_script-&gt;full_path 脚本内容本身 sizeof(zend_persistent_script) 小结一下缓存 OPCodes 的流程: 使用与脚本一一对应的 key 去共享内存中查找已缓存的脚本 如果找到了并且未过期，那就调用 zend_accel_load_script 将其拷贝到当前进程的堆栈中 如果未找到，则调用 opcache_compile_file 初始化，然后将新鲜的结果通过调用 cache_script_in_shared_memory 存入共享内存中 这里面会涉及到内存管理，在后面的篇幅中会介绍。 除了 OPCodes 可被缓存之外，Interned Strings 也可以被缓存。 共享 Interned Strings什么是 Interned Strings？Interned Strings 是 PHP5.4 之后加入的一种很成熟的内存优化机制，简单解释，当 PHP 编译器遇到一个字符串，它就会把它存入一段特殊的内存中，在之后每次碰到相同的字符串时会复用之前的指针。如果你想知道更深入的东西，可以读一下 php string management 。 共享机制Interned Strings 的工作原理如下图： 不过，上面这种复用的方式是基于每个进程的，不同的进程之间并不能共享这块缓存。如下图所示： 这样在高并发的情况下会浪费大量宝贵的内存空间，但是如果使用如下的方式就能解决内存浪费的问题了： 使用 OPCache 把字符串都缓存在一个共享内存里就可以让这部分内容给进程池中的所有 php-fpm worker 读取了。通过调整 opcache.interned_strings_buffer 的值可以控制字符串的缓存占用的存储大小，如果太小的话， OPCache 并不会重启，只是 interned_strings_buffer 不能再增加了，不能命中的将会继续使用 php-fpm 处理请求的子进程自己的私有内存。所以如果允许的话，可以根据需要调大这个值。 Interned Strings 就是 PHP 编译器运行过程中遇到的每一个字符串：变量名、类名、方法名、字符串值、注释，而且注释一般都是一大段文本，它们会吃掉很多内存！ 那么 OPCache 怎么实现这一机制呢？答案当然在源码里：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static int accel_startup(zend_extension *extension)&#123; ... switch (zend_shared_alloc_startup(ZCG(accel_directives).memory_consumption)) &#123; case ALLOC_SUCCESS: if (zend_accel_init_shm() == FAILURE) &#123; accel_startup_ok = 0; return FAILURE; &#125; break; case ALLOC_FAILURE: accel_startup_ok = 0; zend_accel_error(ACCEL_LOG_FATAL, \"Failure to initialize shared memory structures - probably not enough shared memory.\"); return SUCCESS; case SUCCESSFULLY_REATTACHED: zend_shared_alloc_lock(); accel_shared_globals = (zend_accel_shared_globals *) ZSMMG(app_shared_globals); orig_new_interned_string = zend_new_interned_string; orig_interned_strings_snapshot = zend_interned_strings_snapshot; orig_interned_strings_restore = zend_interned_strings_restore; // 这里用 OPCache 中几个实现替代了原有的实现，用于当出现新的 interned string 时，写入共享内存 zend_new_interned_string = accel_new_interned_string_for_php; zend_interned_strings_snapshot = accel_interned_strings_snapshot_for_php; zend_interned_strings_restore = accel_interned_strings_restore_for_php; #ifndef ZTS // 当不是线程安全的时候，调用此函数将 interned strings 从共享内存中拷贝到当前进程内存中 accel_use_shm_interned_strings(); #endif zend_shared_alloc_unlock(); break; case FAILED_REATTACHED: accel_startup_ok = 0; zend_accel_error(ACCEL_LOG_FATAL, \"Failure to initialize shared memory structures - can not reattach to exiting shared memory.\"); return SUCCESS; break; #if ENABLE_FILE_CACHE_FALLBACK case ALLOC_FALLBACK: zend_shared_alloc_lock(); fallback_process = 1; zend_accel_init_auto_globals(); zend_shared_alloc_unlock(); goto file_cache_fallback; break; #endif &#125; ...&#125; 这个实现的方式还是比较简单的，需要注意的是，这个特性不支持线程安全的PHP版本，前面有提到使用的 php-fpm 模式一个任务只由一个子进程处理，不存在线程安全隐忧，不需要特别使用线程安全版本的php，所以是可以享受到这个优势的。 讲到这里，我们已经把 OPCache 在缓存上的两个大的点覆盖到了： OPCodes 缓存 Interned Strings 共享 这两者都和用于进程间资源共享的内存离不开，这块内存区域的管理对于性能提升也至关重要，这就引入了另一个话题，那就是锁。 锁机制OPCache 的内存锁机制很简单：每个尝试往共享内存里写入内容的时候都会使用互斥锁，同时只有一个进程可以写，但是可以同时又很多进程同时读，写操作未完成时并不会阻止同时发生的读操作。 所以服务器运行过程中 OPCache 中出现死锁的概率比较低，但是每次你部署新的代码后，如果流量很大的话，可能会造成大量的写操作积压，这是因为当第一个获得写入机会的进程完成后，其他相同请求编译的结果会因为共享内存已经存在相同的内容而被其替代，这造成了极大的资源浪费，等于这些因为拿不到写机会的进程都干了无用功。 1234567891011121314151617181920/* exclusive lock */zend_shared_alloc_lock(TSRMLS_C);/* Check if we still need to put the file into the cache (may be it was * already stored by another process. This final check is done under * exclusive lock) */bucket = zend_accel_hash_find_entry(&amp;ZCSG(hash), new_persistent_script-&gt;full_path, new_persistent_script-&gt;full_path_len + 1);if (bucket) &#123; zend_persistent_script *existing_persistent_script = (zend_persistent_script *)bucket-&gt;data; if (!existing_persistent_script-&gt;corrupted) &#123; if (!ZCG(accel_directives).revalidate_path &amp;&amp; (!ZCG(accel_directives).validate_timestamps || (new_persistent_script-&gt;timestamp == existing_persistent_script-&gt;timestamp))) &#123; zend_accel_add_key(key, key_length, bucket TSRMLS_CC); &#125; zend_shared_alloc_unlock(TSRMLS_C); return new_persistent_script; &#125;&#125; 怎么解决这个问题呢？有一种办法就是短暂（一秒内）切断服务，然后把所有的页面或接口都调用一遍，保证 OPCache 的共享内存中都已经刷新了一遍内容。这个方法很粗暴，从服务可用性角度说肯定有所损失，但是为了避免出现可能的死锁导致更严重的事故也许主动切断几秒服务可能，甚至前端配合消息队列等设计几乎可以将用户感知降到0，这方面这里就不赘述了。 另外一个问题更值得重视：避免在 php 脚本运行中写 .php 文件，然后还要去用它。原因是，一旦程序要使用一个在运行过程中动态生成的代码，并发量很高的时候意味着每一个 php worker 都会尝试去编译它，这就会导致锁的发生。如果你确实需要这么做，opcache 有一个选项可以配置黑名单： opcache.blacklist-filename。 从技术角度，OPCache 的锁机制并不是很健壮，但是它在 Unix 生态里有很好的兼容性，因为它使用的是 fcntl() 调用。 12345678910111213141516171819202122232425262728293031// ext/opcache/zend_shared_alloc.cvoid zend_shared_alloc_lock(void)&#123;#ifndef ZEND_WIN32#ifdef ZTS tsrm_mutex_lock(zts_lock);#endif#if 0 /* this will happen once per process, and will un-globalize mem_write_lock */ if (mem_write_lock.l_pid == -1) &#123; mem_write_lock.l_pid = getpid(); &#125;#endif while (1) &#123; if (fcntl(lock_file, F_SETLKW, &amp;mem_write_lock) == -1) &#123; if (errno == EINTR) &#123; continue; &#125; zend_accel_error(ACCEL_LOG_ERROR, \"Cannot create lock - %s (%d)\", strerror(errno), errno); &#125; break; &#125;#else zend_shared_alloc_lock_win32();#endif ZCG(locked) = 1;&#125; OPCache 对内存的使用先回顾一下 OPCache 与内存相关的几个特点： OPCache 在 php-fpm 的 master 启动的时候就申请一块内存，所有的 slave 可共享 OPCache 不会释放共享内存 OPCache 在写共享内存的时候会使用 fcntl() 执行 F_SETLKW 共享内存用于以下几个方面 脚本数据结构缓存，包括但不限于 OPCodes Interned Strings 缓存 脚本的 HashTable OPCache 的全局状态信息 这些特性对提升 web 服务性能帮助很大，但是： 世界上没有什么是不过期的 那 OPCache 怎么判断一个对象的缓存是否过期？阅读 opcache 的配置文档会发现两个很明显相关的选项： opcache.validate_timestamps opcache.revalidate_freq opcache.revalidate_path 当 php.ini 中打开了 opcache.validate_timestamps 选项时，OPCache 的编译阶段（persistent_compile_file()）会调用 validate_timestamp_and_record() 检查缓存中脚本的时间戳和文件的时间戳。实现代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344...zend_op_array *persistent_compile_file(zend_file_handle *file_handle, int type)&#123;.../* If script is found then validate_timestamps if option is enabled */ if (persistent_script &amp;&amp; ZCG(accel_directives).validate_timestamps) &#123; // 校验时间戳 if (validate_timestamp_and_record(persistent_script, file_handle) == FAILURE) &#123; ... &#125; &#125;...&#125;...int validate_timestamp_and_record(zend_persistent_script *persistent_script, zend_file_handle *file_handle)&#123; if (ZCG(accel_directives).revalidate_freq &amp;&amp; persistent_script-&gt;dynamic_members.revalidate &gt;= ZCG(request_time)) &#123; // 如果设置了 revalidate_freq 并且 缓存中的 persistent_script 存的下一次检查脚本时间仍然在请求发生之后，则不检查 return SUCCESS; &#125; else if (do_validate_timestamps(persistent_script, file_handle) == FAILURE) &#123; // else 检查时间戳 return FAILURE; &#125; else &#123; // else 检查通过，不需要更新缓存中的内容，但是更新 下一次检查时间 persistent_script-&gt;dynamic_members.revalidate = ZCG(request_time) + ZCG(accel_directives).revalidate_freq; return SUCCESS; &#125;&#125;...static zend_persistent_script *opcache_compile_file(zend_file_handle *file_handle, int type, char *key, unsigned int key_length, zend_op_array **op_array_p)&#123;...if (ZCG(accel_directives).validate_timestamps) &#123; /* Obtain the file timestamps, *before* actually compiling them, * otherwise we have a race-condition. */ new_persistent_script-&gt;timestamp = timestamp; // 记录下一次需要检查脚本是否变更的时间 new_persistent_script-&gt;dynamic_members.revalidate = ZCG(request_time) + ZCG(accel_directives).revalidate_freq; &#125;&#125;... 那么，如果缓存过期了怎么办？再来看看这一段代码：12345678910111213141516// 校验时间戳if (validate_timestamp_and_record(persistent_script, file_handle) == FAILURE) &#123;zend_shared_alloc_lock();if (!persistent_script-&gt;corrupted) &#123; persistent_script-&gt;corrupted = 1; persistent_script-&gt;timestamp = 0; ZSMMG(wasted_shared_memory) += persistent_script-&gt;dynamic_members.memory_consumption; if (ZSMMG(memory_exhausted)) &#123; zend_accel_restart_reason reason = zend_accel_hash_is_full(&amp;ZCSG(hash)) ? ACCEL_RESTART_HASH : ACCEL_RESTART_OOM; zend_accel_schedule_restart_if_necessary(reason); &#125;&#125;zend_shared_alloc_unlock();persistent_script = NULL;&#125; 从中可以看出，OPCache 会首先调用 zend_shared_alloc_lock()，然后将 persistent_script 的 设置为 corrupted，然后再判断共享内存又没有被标记 memory_exhausted=1，如果已经满了，那就调用 zend_accel_schedule_restart_if_necessary();，这个函数的实现如下1234567void zend_accel_schedule_restart_if_necessary(zend_accel_restart_reason reason)&#123; if ((((double) ZSMMG(wasted_shared_memory)) / ZCG(accel_directives).memory_consumption) &gt;= ZCG(accel_directives).max_wasted_percentage) &#123; // 如果已经置为 wasted 的内存空间已经大于 php.ini 中设置的最大比例，则计划重启 zend_accel_schedule_restart(reason); &#125;&#125; 所以，已经被设置为 wasted 的内存大于（opcache.max_wasted_percentage）设置的比例时，会触发 OPCache 的重启机制，它的重启机制是很复杂的，准备再另外一篇中重点解析。因为 OPCache 的重启是会锁住共享内存，重设状态，完全清理空间，然后再释放锁，一旦在流量很高的时候频繁触发重启，那带来的性能影响将是灾难性的。所以对性能有高要求的话有一条军规： 永远不要超出共享内存 如何做到这一点，或者说避免出现这种情况的做法是在线上服务器上关闭 validate_timestamps ，这种做法可以保证你永远不会触发重启，可以按照下面的步骤部署新的代码： 切断流量 清空 Opcache，使用 opcache_reset() 或者直接重启 FPM 部署新版本代码 重启 FPM, 对所有的页面、接口都遍历执行一遍 切回流量 这些步骤用几十行 shell 脚本就可以搞定，如果有一些请求一直无法结束导致 fpm 无法完成重启可以直接 kill -9 强制杀死进程。还有一种可靠的方式是：使用灰度发布，这种方式一般适用于大型线上项目，可以最大程度保证服务平滑切换。 另外和这个话题相关的有一个问题：在部署代码的时候我们遇到过一个很常见的问题，那就是刚部署的代码不能立即看到效果，这让产品很抓狂。经过分析发现，这是因为部署代码的方式使用的是常见的先部署代码，再修改软连接的目标目录到新的代码目录下的方式，而 php-fpm 得到的访问请求是一个软连接，而缓存中 realpath_cache 仍然指向老的代码地址，故而新发布的代码没有生效。解决这个问题有多种办法，我们使用的是在 nginx 层配置成绝对路径，很好的解决了问题。 总结一下到这里，OPCache 缓存部分的内容基本介绍完了，主要就是涉及到 OPCodes 缓存和 Interned Strings 缓存两大块，然后就是共享内存的管理也很重要，希望对大家开发和性能优化有一些指导意义，抽空再分析一下操作码优化这一块的内容。 因为个人能力有限，所以文中有一些不准确的地方敬请指出。vaivei@foxmail.com 参考资料本文相当多的内容源自: PHP’s OPCache extension review 如何正确发布PHP代码 - 火丁 PHP strings management opcache configuration 浅谈 Node.js 和 PHP 进程管理 PHP 源代码 使用 Opengrok 阅读源代码"}]}