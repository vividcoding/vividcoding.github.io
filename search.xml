<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>事件溯源：它是什么，为何这么厉害</title>
      <link href="/2020/03/08/Why-event-sourcing-so-incrediable/"/>
      <url>/2020/03/08/Why-event-sourcing-so-incrediable/</url>
      <content type="html"><![CDATA[<h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>在我们讨论事件溯源之前，先简单介绍一下web开发的现状。当前流行的web开发本质上是数据库驱动的。在设计Web应用最开始的阶段，一般会对业务进行建模，并抽象成数据库模型。如果使用MySQL，意味着需要设计表结构，索引等；如果使用Mongo，则需要设计文档结构和集合。这种方式会潜移默化的引导开发者按照如下方式去设计：业务运转起来后会如何使用数据？<br><img src="https://raw.githubusercontent.com/vividcoding/vividcoding.github.io/master/images/202003/es_data_driven.png" alt="data table driven"></p><h3 id="这种思想存在三个潜在的根本问题："><a href="#这种思想存在三个潜在的根本问题：" class="headerlink" title="这种思想存在三个潜在的根本问题："></a>这种思想存在三个潜在的根本问题：</h3><h4 id="1-不能直观表达业务的目的"><a href="#1-不能直观表达业务的目的" class="headerlink" title="1. 不能直观表达业务的目的"></a>1. 不能直观表达业务的目的</h4><p>这种方式让我们不根据状态来思考和交流。比如我和你在希格码2层领盒饭的时候问遇到了一个熟人，问他“最近还好吗“，他回答我：”嗯，我有一个篮球，我会写PHP，我单身“。<br>这个回答是不是很奇怪？实际上我们从数据库中取出来数据的时候就是这样的。<br>如果他的回答是这样：<br>”我这周一买了一个新篮球，这周新启动的一个项目开始用PHP实现，最近加班比较多，上周五晚上10点11分女朋友跟我分手了“。<br>显而易见，第二种方式他告诉我上次见面到现在你发生了什么事情，这样我能根据上次的交谈得出你现在是什么样的状态，毕竟我们已经认识了。<br>概括一下，他只需要用最简单的方式告诉我最近他发生的事情即可。    </p><h4 id="2-单一数据模型"><a href="#2-单一数据模型" class="headerlink" title="2. 单一数据模型"></a>2. 单一数据模型</h4><p>在上述的设计中，我们读写都是基于同一种存储模型的。因此我们在设计的时候会考虑怎么写入数据以及怎么在设计的数据结构上做查询。这种方式对于简单的应用是非常高效的，比如：一个todo list，但是一旦这个todo list变成了一个很复杂的大型应用：时间管理综合解决方案blabla..，我们背后就会有各种服务来支撑这个大型应用，比如数据是不是要同步给手机Calendar？能不能直接从其他应用中把Todo同步过来？这些都是会面临的问题。随着业务的发展会出现各种各样的数据查询需求，如何让查询持续高效？传统的数据库在面临数据量巨大场景下变更索引或者加字段的成本都是比较高的，尽管它们做了很多优化让这些操作变得足够平滑，但是并没有从本质上解决问题，最终数据库将会变的不可维护，变更成本高昂。</p><h4 id="3-丢失业务关键信息"><a href="#3-丢失业务关键信息" class="headerlink" title="3. 丢失业务关键信息"></a>3. 丢失业务关键信息</h4><p>这个是最严重的问题。使用标准的表驱动系统时，你只能知道当前的状态，不会知道它是如何变成当前的状态的。如果我需要查询一个用户变更了多少次邮箱？你可能需要去流水日志里去查，但是流水日志非常多，因此又需要考虑流水日志如何存储，如何索引。如果需求是：有多少人往购物车里加过商品，又删掉了它，后来过了一个月他们又买了它。这些需求可能都需要拍个期，并且最关键的是，传统的实现都是对业务具有侵入性的，随着时间的流逝和产品的来来去去，需要维护的表，需要join的表会越来越多。</p><h2 id="事件溯源（Event-Sourcing"><a href="#事件溯源（Event-Sourcing" class="headerlink" title="事件溯源（Event Sourcing)"></a>事件溯源（Event Sourcing)</h2><p>事件溯源的思想是完全相反的。在系统存储设计的时候关心变化，而不是最终状态。它是使用事件序列来对系统进行建模的一种实践。</p><blockquote><p>举个栗子：现在我们有一个“购物车”，购物车可以往里添加商品、删除商品、结账。<br>一个购物车的生命周期按照事件序列的方式进行建模：</p></blockquote><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h4 id="1-创建购物车"><a href="#1-创建购物车" class="headerlink" title="1. 创建购物车"></a>1. 创建购物车</h4><h4 id="2-添加商品A到购物车"><a href="#2-添加商品A到购物车" class="headerlink" title="2. 添加商品A到购物车"></a>2. 添加商品A到购物车</h4><h4 id="3-添加商品B到购物车"><a href="#3-添加商品B到购物车" class="headerlink" title="3. 添加商品B到购物车"></a>3. 添加商品B到购物车</h4><h4 id="4-从购物车中移出商品A"><a href="#4-从购物车中移出商品A" class="headerlink" title="4. 从购物车中移出商品A"></a>4. 从购物车中移出商品A</h4><h4 id="5-结账"><a href="#5-结账" class="headerlink" title="5. 结账"></a>5. 结账</h4><p><img src="https://raw.githubusercontent.com/vividcoding/vividcoding.github.io/master/images/202003/event_driven.png" alt="data table driven"></p><p>这就是一个购物车的完整生命周期，从创建到结账。这就是事件溯源思想，我们可以基于这个事件序列提炼出业务行为的各种特征。<br>任何业务流程都可以按照这种思想进行抽象建模。实际上：每一个流程都按照一个事件来进行建模。我们和任意一个领域的专家讨论的时候，他们不懂计算机，不会跟你说“表”、“join”，除非你给他们灌输好了这些计算机的术语，他们只会告诉你业务流程，每一个步骤需要什么物料，如何加工物料，下一步做什么。</p><h3 id="如何实施业务规则？"><a href="#如何实施业务规则？" class="headerlink" title="如何实施业务规则？"></a>如何实施业务规则？</h3><p>问题来了，大部分业务都会存在一些约束，比如：没有准生证生超生孩子如果不交社会抚养费不给上户口，孩子也就没办法上学。这种规则显然不可能轻易打破。在上面购物车的例子中存在的约束是：一件商品需要存在于购物车中才可以被移除。不可能移除一个不在购物车里的商品，这种事件序列本身是不可能发生的。因此在实现这种约束的时候需要回答一个问题：“这个商品在不在购物车中？“，如何在无状态下实现这个逻辑。</p><p>解决这个问题的办法非常简单，你只需要检查添加该商品的事件是否发生过，并且之前没有移除事件发生，只要满足这两个条件即可认为移出购物车事件是可执行的，这就实现了我们的约束逻辑。</p><p>这是在使用事件溯源思想设计系统时解决业务问题的标准套路，即，对该实体发生过的事情进行片段或者完整的回放即可得到一个判断约束条件是否满足的状态。这种方式通常被称为“Projection the Events”，结果称为“投影”。</p><h3 id="事件溯源实现业务约束成本是否昂贵？"><a href="#事件溯源实现业务约束成本是否昂贵？" class="headerlink" title="事件溯源实现业务约束成本是否昂贵？"></a>事件溯源实现业务约束成本是否昂贵？</h3><p>答案是否定的。要实现业务约束一般只需要事件的一个微小的子集。实现过程从实体的历史事件中过滤出需要的部分，这就变成了一个简单的SELECT查询，将需要的事件从表张查询出来放到内存中做一次回放得到一个最终态。这种做法非常轻量，大部分的计算都在本地做，而不是写一个复杂的查询在数据库中做，因为我们在复杂业务实践时需要尽量避免在查询中使用计算表达式，为了提升吞吐量也需要尽量的减少和数据库之间的网络通信开销。</p><h3 id="如何将数据展示给用户？"><a href="#如何将数据展示给用户？" class="headerlink" title="如何将数据展示给用户？"></a>如何将数据展示给用户？</h3><p>如果每个状态的都由事件序列去重放出来的话，我们需要如何获得显示给用户的数据？是不是每次查询都需要对事件进行完整的重放然后得到最终结果？</p><p>答案是否定的，这么做简直荒谬。</p><p>取而代之的解决方案是在后台对数据进行构建，并立刻存入数据库中。这样当我们需要查询完整数据的时候只需要根据需求查询就可以了（一般是主键），实际上，这相当于用一个缓存存储了对象的最终状态。</p><p>到现在为止，你应该体会到了事件溯源思想的魅力所在。使用这种方式，我们抛弃了传统数据库设计范式，无需被现有的数据库表结构羁绊。每当需要新的数据组织形式的时候那就按照需要去自行重放并组织就好了。这给了不同业务读取数据充分的自由，弱水三千，你只取一瓢也是可以的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>前面我们在介绍事件溯源思想的时候已经提到了一些优势，接下来我们深入的介绍分析其更大的益处。</p><h4 id="1-短暂的数据结构，永存的事件流水"><a href="#1-短暂的数据结构，永存的事件流水" class="headerlink" title="1. 短暂的数据结构，永存的事件流水"></a>1. 短暂的数据结构，永存的事件流水</h4><p>由于所有的状态都来自于事件，你不在需要被数据的当前状态（组织形式以及具体的状态）所限制。如果需要一种新的数据视图，需要做的仅仅是按照你想要的方式做一次会放即可。和复杂的数据迁移脚本说再见吧，你只需要去用你需要的方式重放事件就可以把原来的数据抛弃了。</p><h4 id="2-和领域专家愉快的讨论业务问题"><a href="#2-和领域专家愉快的讨论业务问题" class="headerlink" title="2. 和领域专家愉快的讨论业务问题"></a>2. 和领域专家愉快的讨论业务问题</h4><p>前文提到过，一般行业专家不会按照计算机从业人员的思维去表述问题，而是会按照业务流程去描述。构建一个事件溯源的系统时，我们对他们原汁原味的描述进行建模来取代传统对这些信息进行提取，转换成计算机语言的方式，这样能避免因为产品或开发对业务的理解偏差产生的信息丢失问题。这样也能帮助我们与他们（领域专家）的沟通更加顺畅，因为产研在了解需求时会顺着他们的思维和表述方式去沟通，讨论，这让软件开发完全不一样了。</p><h4 id="3-极具表现力的模型"><a href="#3-极具表现力的模型" class="headerlink" title="3. 极具表现力的模型"></a>3. 极具表现力的模型</h4><p>事件溯源思想引导你把模型的事件作为第一个对象进行建模，而无需考虑各种对数据更新、查询的需求。这意味着可以最大限度的设计一个极度接近业务流程本身的模型出来。这种模型设计的思想可以避免因为传统的数据组织方式导致业务流程中状态变化的一些流程信息，将一些隐藏的很深的变化也能清晰的表述出来。所以说这种建模的方式具有很好的表现力，不仅有结果，还有结果产生的过程。</p><h4 id="4-上报，上报，上报"><a href="#4-上报，上报，上报" class="headerlink" title="4. 上报，上报，上报"></a>4. 上报，上报，上报</h4><p>大部分情况下上报的代码不需要再写在核心业务里了，需要不同的上报实际上也可以看作一种不同的数据组织方式，为它单独开发一个简单的脚本就可以实现，这样让所有上报变成了非侵入式的，并且历史的车轮压过的轨迹可以帮你解释所有的问题。想想都开心，我们有些业务总是不断的有新的上报需求，由于对业务不熟悉，对资源不熟悉等各种借口导致我们的业务代码里存在十几个甚至几十个上报，非常丑陋，甚至他们时串行的同步的，就算有数据上报的AGENT服务也是需要浪费很多的计算资源的。说的升华一下，这种数据模型设计方式让你拥有了一台时间机器，除了未来，哪里都可以去。</p><h4 id="5-微服务由此开启"><a href="#5-微服务由此开启" class="headerlink" title="5. 微服务由此开启"></a>5. 微服务由此开启</h4><p>微服务的好处网上有很多资料介绍，大家如何从传统的中心化服务向微服务过度也是各有神通。而事件溯源的模型设计方式让微服务化面临的跨系统交互问题迎刃而解，答案就是事件监听器。事件监听器监听事件，并执行重放，按照自己的方式组织数据，无需额外的改造成本即可让现有的业务平滑的过度。<br>举个例子，一篇文章的一个字段变化了，我们需要通知到五个下游，通过BOSS同步上报也好、RPC接口通知、通过binlog订阅、各种方式，侵入到业务代码里。这里不讨论代码写得是否优雅，效率是否高，传统的方式我们一般都是在业务代码里直接去做。好一点的会有框架的事件机制，可能更好的还能用异步队列去做。而事件溯源的方式将只需要在存储层将这个文章的变更按照一个事件写入的有序存储里（Kafka），后续动作交给事件的调度服务去完成，不同的服务之间的交互便解耦了。</p><h4 id="6-对数据库的要求不再喋喋不休"><a href="#6-对数据库的要求不再喋喋不休" class="headerlink" title="6. 对数据库的要求不再喋喋不休"></a>6. 对数据库的要求不再喋喋不休</h4><p>事件存储无需性能非常好的数据库或机器，一个简单的MySQL都能达到很高的吞吐能力，因为写入是顺序的，修改是不存在的。</p><h4 id="7-数据库更换成本很低"><a href="#7-数据库更换成本很低" class="headerlink" title="7. 数据库更换成本很低"></a>7. 数据库更换成本很低</h4><p>由于事件的数据结构非常简单，不管是传统的关系型数据库还是MongoDB还是OrientDB这类图数据库，都是可以用来存储事件的，可以非常低成本的更换存储方案。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>所有事务皆是有利有弊的，这是客观规律，不是鲁迅说的。下面是一些需要注意的问题：</p><h4 id="1-最终一致性"><a href="#1-最终一致性" class="headerlink" title="1. 最终一致性"></a>1. 最终一致性</h4><p>理论上，基于事件溯源思想设计的系统即是符合最终一致性的。这意味着，一个事件发生之后，其他系统不会立刻感知到，在他们收到并处理之前会有小于100ms的延迟来实现我们所说的最终一致性。也就是说，你不能保证你的系统里展示的数据就是当时最新的数据，听起来好像不可接受，实际上并不是，因为现在大部分的应用和服务是由人去发起的动作，这些动作本身就伴随着一定的延迟，几乎是无感知的，因为实际情况下这样的设计甚至会让整体的速度提升不少。老实说，这有点塞翁失马的感觉，符合最终一致性的系统是具备容错特点并且能应对服务中断的。如果你在使用微服务或者无状态架构构建一个分布式应用， </p><h4 id="2-事件升级"><a href="#2-事件升级" class="headerlink" title="2. 事件升级"></a>2. 事件升级</h4><p>事件的模型会随着时代的发展而变化，因此在最初设计事件模型时需要认真考虑其扩展性。当事件模型需要升级时，历史数据也需要被整体更新一遍，这件事可以是触发式的，并不一定要离线把事件做好，可以在读取事件时将事件模型升级到新版本。因此提前设计好事件升级的机制可以帮助你轻松应对这类问题。</p><h4 id="3-开发人员需要deprograming"><a href="#3-开发人员需要deprograming" class="headerlink" title="3. 开发人员需要deprograming"></a>3. 开发人员需要deprograming</h4><p>在实践过程中，开发人员需要首先转变开发的模式，从传统的先涉及表实体转为先设计实体变更模型，在开发过程中需要更多的去关注业务本身而不是考虑怎么写CRUD。</p><p>到这里大家可能已经感受到了事件溯源的魅力了，反正我的领导在看到这个思想的时候非常激动的让我们停止了数据库表设计的工作直接转向这种构建系统的思路上来。的确，在构建大型分布式业务系统时，这种方式让核心的数据模型设计本身可以不脱离实际业务流程，不做那些信息有损的抽象，讨论业务需求的时候能够尽量用业务领域专家的思维方式来沟通。学习的过程可能是坎坷的，相信我，这个不仅看起来美，真香！</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>MySQL latin1 字符集引起的一个小问题分析</title>
      <link href="/2018/09/02/A-small-tip-about-mysql-latin1-charset/"/>
      <url>/2018/09/02/A-small-tip-about-mysql-latin1-charset/</url>
      <content type="html"><![CDATA[<p>神勇的latin1啥都能存，但是要慎用。<br><a id="more"></a></p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_articles`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`article_id`</span> <span class="built_in">varchar</span>(<span class="number">14</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`sub_category_cn`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_article_id`</span> (<span class="string">`article_id`</span>)</span><br><span class="line">  ) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=latin1</span><br></pre></td></tr></table></figure><h3 id="一条插入操作"><a href="#一条插入操作" class="headerlink" title="一条插入操作"></a>一条插入操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`t_articles`</span> (<span class="string">'article_id'</span>, <span class="string">`sub_category_cn`</span>) <span class="keyword">values</span> (<span class="string">"20180830012203"</span>, <span class="string">"海鸟和鱼相爱，只是一场意外。"</span>);</span><br></pre></td></tr></table></figure><p>插入的结果可能有两种，一种是如下：</p><table><thead><tr><th>article_id</th><th>sub_category_cn</th></tr></thead><tbody><tr><td>20180830012203</td><td>海鸟和鱼相爱，只是一x</td></tr></tbody></table><p>另一种是直接报错，无法插入。</p><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>原因大概率是因为<code>sub_category_cn</code>字段类型是varchar，varchar(32)能存储32个字符，超过32个字符的部分会被截断，而如果连接采用了<code>strict=true</code>严格模式则插入会直接报错。那么问题来了：</p><blockquote><p><strong>“海鸟和鱼相爱，只是一场意外。”这句话带上标点符号也没有超过32个字，为什么会被截断？海鸟和鱼相爱到底是不是意外？</strong></p></blockquote><p>看看<code>latin1</code> 字符集对于数据的处理方式：</p><blockquote><p>ISO/IEC 8859-1:1998, Information technology — 8-bit single-byte coded graphic character sets</p></blockquote><p>参考维基百科中对于这个标准的阐述可以明确，Latin1编码格式中，每个字符占8bit，也就是一个字节。而utf8编码规则也很简单：</p><p>1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。</p><p>2）对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</p><table><thead><tr><th>Unicode符号范围</th><th>UTF-8编码方式</th></tr></thead><tbody><tr><td>0000 0000-0000 007F</td><td>0xxxxxxx</td></tr><tr><td>0000 0080-0000 07FF</td><td>110xxxxx 10xxxxxx</td></tr><tr><td>0000 0800-0000 FFFF</td><td>1110xxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>0001 0000-0010 FFFF</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr></tbody></table><p>到这里，大概能猜到<code>latin1</code>作为连接字符集时 MySQL<code>varchar</code>类型对于字符长度计算方式了.</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">names</span> latin1;</span><br></pre></td></tr></table></figure><p>告诉 MySQL 所有的 SQL 语句会以 latin1 字符集发送给服务端，请服务端按照 latin1 的方式进行解析。因此，当一个 UTF8 编码的汉字被发送过去时，实际上 MySQL 会把二进制的每8位当做一个字符来处理，而不是用 utf8 编码的方式去解析头八位看这个字符有几个字节。因此最终的结果是每个汉字会被当做3~4个字符来处理。</p><p>接下来做个简单的实验：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 终端编码为utf8，连接字符集为 latin1</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">names</span> latin1;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">char_length</span>(<span class="string">"海鸟海鸟"</span>);</span><br></pre></td></tr></table></figure></p><p>result:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+------------------------+</span><br><span class="line">| char_length(&quot;海鸟海鸟&quot;) |</span><br><span class="line">|                     12 |</span><br><span class="line">+------------------------+</span><br></pre></td></tr></table></figure><p>采用 <code>set names latin1</code> 作为连接字符集，计算出来的<code>UTF8</code>编码的字符长度为 3*4=12。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 终端编码为utf8，连接字符集为 utf8</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">names</span> latin1;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">char_length</span>(<span class="string">"海鸟海鸟"</span>);</span><br></pre></td></tr></table></figure><p>result:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+------------------------+</span><br><span class="line">| char_length(&quot;海鸟海鸟&quot;) |</span><br><span class="line">|                     4  |</span><br><span class="line">+------------------------+</span><br></pre></td></tr></table></figure><p>采用 <code>set names utf8;</code> 作为连接字符集，计算出来的<code>UTF8</code>编码的字符长度为 4，符合预期。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>如果不用strict模式可能发现不了这个问题；</li><li>设计mysql表需要考虑的问题很多，字符集的选择就是一个很重要又很容易被忽视的点。</li></ol><p>看起来<code>latin1</code>对于字符串存储可以说是万能的，因为它单字节处理的方式可以让多字节编码也可以被正常存入数据库。在近几年的工作实践中经常会遇到为了存储emoji表情需要改造数据表的字符集的情况，大多数方案都是改为<code>utf8mb4</code>这种字符编码，它是utf8的扩充，能兼容utf8。而实际上<code>latin1</code>也是可以存储emoji表情的，不知道有没有团队踩过坑？</p><p>听说世界上有10种人，一种是懂二进制的，一种是不懂二进制的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zh.wikipedia.org/wiki/UTF-8" target="_blank" rel="noopener">维基百科:UTF-8</a></li><li><a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1" target="_blank" rel="noopener">维基百科:ISO/IEC 8859-1</a></li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/charset-we-sets.html" target="_blank" rel="noopener">MySQL 5.7 Reference Manual: West European Character Sets</a></li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/char.html" target="_blank" rel="noopener">MySQL 5.7 Reference Manual: The CHAR and VARCHAR Types</a></li><li><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">阮一峰的网络日志：字符编码笔记：ASCII，Unicode 和 UTF-8</a></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>为什么使用INT型数据查询varchar字段会导致全表扫描</title>
      <link href="/2018/05/15/why-using-an-integer-to-select-varchar-cause-a-full-table-scan/"/>
      <url>/2018/05/15/why-using-an-integer-to-select-varchar-cause-a-full-table-scan/</url>
      <content type="html"><![CDATA[<p>一个简单的查询语句引发的血案。<br><a id="more"></a></p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">form</span> <span class="string">`db_articles`</span>.<span class="string">`tbl_articles`</span> <span class="keyword">where</span> article_id=<span class="number">2018010100000</span> <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="string">`db_articles`</span> <span class="comment">/*!40100 DEFAULT CHARACTER SET latin1 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tbl_articles`</span> (</span><br><span class="line">  <span class="string">`article_id`</span> <span class="built_in">varchar</span>(<span class="number">14</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span></span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`article_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=latin1</span><br></pre></td></tr></table></figure><p>查询的语句非常简单，但是却存在巨大的隐患，因为无法用到索引会导致执行查询语句需要扫描整张表的数据，如果这张表非常大的话会导致整个数据库服务器I/O被占满，接近宕机状态。</p><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><h3 id="查询结果对吗？"><a href="#查询结果对吗？" class="headerlink" title="查询结果对吗？"></a>查询结果对吗？</h3><p>首先，这个场景下这条语句能否查出结果呢？不一定，这个完全需要在业务侧保证生成的<code>article_id</code>字段唯一，不然就会导致下面的情况：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`db_articles`</span>.<span class="string">`tbl_articles`</span> (<span class="string">`article_id`</span>) <span class="keyword">VALUES</span> (<span class="string">'20180515000000'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`db_articles`</span>.<span class="string">`tbl_articles`</span> (<span class="string">`article_id`</span>) <span class="keyword">VALUES</span> (<span class="string">'20180515000001'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`db_articles`</span>.<span class="string">`tbl_articles`</span> (<span class="string">`article_id`</span>) <span class="keyword">VALUES</span> (<span class="string">'020180051500'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`db_articles`</span>.<span class="string">`tbl_articles`</span> (<span class="string">`article_id`</span>) <span class="keyword">VALUES</span> (<span class="string">'20180051500'</span>);</span><br></pre></td></tr></table></figure></p><p>查询语句如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> db_articles;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tbl_articles <span class="keyword">where</span> article_id=<span class="number">20180051500</span>;</span><br></pre></td></tr></table></figure></p><p>查询结果如下：<br>| article_id |<br>| - |<br>| 020180051500 |<br>|    20180051500 |</p><p>可以看出，查询结果不一定是预期结果，这条查询的问题在于 where 条件里 article_id=20180051500, 而 mysql 认为 “020180051500” = 20180051500，因此查出了错误的结果。既然知道该字段类型是VARCHAR，那在查询的时候一定要保证 where 条件的值在程序中以字符串类型发送到数据库。</p><p>正确的查询：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> db_articles;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tbl_articles_2 <span class="keyword">where</span> article_id=<span class="string">"20180051500"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tbl_articles_2 <span class="keyword">where</span> article_id=<span class="keyword">CONCAT</span>(<span class="number">20180051500</span>);</span><br></pre></td></tr></table></figure></p><p>再来看一个官方提供的例子：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">'18015376320243458'</span> = <span class="number">18015376320243458</span>;</span><br><span class="line">        -&gt; 1</span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">'18015376320243459'</span> = <span class="number">18015376320243459</span>;</span><br><span class="line">        -&gt; 0</span><br></pre></td></tr></table></figure><p>上面这个例子我在自己装的MySQL版本上已经无法得到官方提供的结果，不过用下面的测试可以得出相似的结果：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">'999999999999999999999999999999999999999999999999999999999999999999999999999999999'</span>=<span class="number">999999999999999999999999999999999999999999999999999999999999999999999999999999999</span></span><br><span class="line">    -&gt; <span class="number">1</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">'1000000000000000000000000000000000000000000000000000000000000000000000000000000000'</span>=<span class="number">1000000000000000000000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line">    -&gt; <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>上面第一句，81位数字，都是9，比较出来相等，但是+1之后就不等了。</p><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>MySQL文档中的解释：<a href="https://dev.mysql.com/doc/refman/5.7/en/type-conversion.html" target="_blank" rel="noopener">12.2 Type Conversion in Expression Evaluation</a></p><blockquote><p>If one or both arguments are NULL, the result of the comparison is NULL, except for the NULL-safe &lt;=&gt; equality comparison operator. For NULL &lt;=&gt; NULL, the result is true. No conversion is needed.</p></blockquote><blockquote><p>If both arguments in a comparison operation are strings, they are compared as strings.</p></blockquote><blockquote><p>If both arguments are integers, they are compared as integers.</p></blockquote><blockquote><p>Hexadecimal values are treated as binary strings if not compared to a number.</p></blockquote><blockquote><p>If one of the arguments is a TIMESTAMP or DATETIME column and the other argument is a constant, the constant is converted to a timestamp before the comparison is performed. <strong>This is done to be more ODBC-friendly. This is not done for the arguments to IN(). To be safe, always use complete datetime, date, or time strings when doing comparisons</strong>. For example, to achieve best results when using BETWEEN with date or time values, use CAST() to explicitly convert the values to the desired data type.</p></blockquote><blockquote><p>A single-row subquery from a table or tables is not considered a constant. For example, if a subquery returns an integer to be compared to a DATETIME value, the comparison is done as two integers. The integer is not converted to a temporal value. To compare the operands as DATETIME values, use CAST() to explicitly convert the subquery value to DATETIME.</p></blockquote><blockquote><p>If one of the arguments is a decimal value, comparison depends on the other argument. The arguments are compared as decimal values if the other argument is a decimal or integer value, or as floating-point values if the other argument is a floating-point value.</p></blockquote><blockquote><p><strong>In all other cases, the arguments are compared as floating-point (real) numbers.</strong></p></blockquote><ul><li>两个参数至少有一个是 NULL 时，比较的结果也是 NULL，例外是使用 &lt;=&gt; 对两个 NULL 做比较时会返回 1，这两种情况都不需要做类型转换</li><li>两个参数都是字符串，会按照字符串来比较，不做类型转换</li><li>两个参数都是整数，按照整数来比较，不做类型转换</li><li>十六进制的值和非数字做比较时，会被当做二进制串，和数字做比较时会按下面的规则处理</li><li>有一个参数是 TIMESTAMP 或 DATETIME，并且另外一个参数是常量，常量会被转换为 timestamp</li><li>有一个参数是 decimal 类型，如果另外一个参数是 decimal 或者整数，会将整数转换为 decimal 后进行比较，如果另外一个参数是浮点数，则会把 decimal 转换为浮点数进行比较</li><li>所有其他情况下，两个参数都会被转换为浮点数再进行比较</li></ul><p>再参考 <a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-indexes.html" target="_blank" rel="noopener">8.3.1 How MySQL Uses Indexes</a>中提到的：</p><blockquote><p>Comparison of dissimilar columns (comparing a string column to a temporal or numeric column, for example) may prevent use of indexes if values cannot be compared directly without conversion. For a given value such as 1 in the numeric column, it might compare equal to any number of values in the string column such as ‘1’, ‘ 1’, ‘00001’, or ‘01.e1’. <strong>This rules out use of any indexes for the string column</strong>.</p></blockquote><p>如果做值的比较时需要根据上面的机制做类型转换的话，考虑到1可能等于’1’,’ 1’,’00001’甚至 ‘01.e1’,因此非常大的概率导致无法使用到索引。但是如果列类型是数字型，where条件是字符串的情况是可以用到索引的，因为字符串会被转换成数字，而数字之间比较会出现非确定结果的情况。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>mysql 的隐式类型转换给使用者带来的方便可能伴随着非常沉重的代价，需要多加注意，尤其是随着业务发展，老业务DB需要变更字段类型（int转成varchar还是比较常见的)时需要非常慎重。</p>]]></content>
      
      
        <tags>
            
            <tag> mysql 查询优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PHP7 FPM 启动源码分析&lt;一&gt;</title>
      <link href="/2017/05/26/PHP7-FPM-internels/"/>
      <url>/2017/05/26/PHP7-FPM-internels/</url>
      <content type="html"><![CDATA[<p>从源码角度去分析 FPM 的启动步骤<br><a id="more"></a></p><h1 id="PHP-FPM-启动分析"><a href="#PHP-FPM-启动分析" class="headerlink" title="PHP-FPM 启动分析"></a>PHP-FPM 启动分析</h1><p>PHP-FPM 的源代码在 php-src/sapi/fpm 目录中，因为 php 是用 C 语言写的，所以第一步就是找到 main() 函数。fpm_main.c 文件的 1571 行开始便是 main 函数的主体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> exit_status = FPM_EXIT_OK;</span><br><span class="line">    <span class="keyword">int</span> cgi = <span class="number">0</span>, c, use_extended_info = <span class="number">0</span>;</span><br><span class="line">    zend_file_handle file_handle;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* temporary locals */</span></span><br><span class="line">    <span class="keyword">int</span> orig_optind = php_optind;</span><br><span class="line">    <span class="keyword">char</span> *orig_optarg = php_optarg;</span><br><span class="line">    <span class="keyword">int</span> ini_entries_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max_requests = <span class="number">500</span>; <span class="comment">// 默认最大请求数</span></span><br><span class="line">    <span class="keyword">int</span> requests = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> fcgi_fd = <span class="number">0</span>;</span><br><span class="line">    fcgi_request *request;</span><br><span class="line">    <span class="keyword">char</span> *fpm_config = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> *fpm_prefix = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> *fpm_pid = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> test_conf = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> force_daemon = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> force_stderr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> php_information = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> php_allow_to_run_as_root = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段是 main 函数变量初始化部分的代码，这里主要关注 max_requests, requests, fcgi_fd , *request 这几个变量。</p><p>首先是 <code>max\_requests</code>，配置过 php-fpm 的开发者都应该知道可以在配置文件中配置 pm.max_requests 的值，在文档中有详细的说明它的作用：</p><blockquote><p>设置每个子进程重生之前服务的请求数。对于可能存在内存泄漏的第三方模块来说是非常有用的。如果设置为 ‘0’ 则一直接受请求，等同于 PHP_FCGI_MAX_REQUESTS 环境变量。默认值：0。</p></blockquote><p>可以看到它的默认值是 <code>500</code>，按照文档中所描述的，如果处理的请求数达到 500 之后，会触发改进程的 “重生”，后面我们会介绍这个过程。</p><p>继续往下看：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">zend_signal_startup();</span><br><span class="line"></span><br><span class="line">sapi_startup(&amp;cgi_sapi_module);</span><br><span class="line">cgi_sapi_module.php_ini_path_override = <span class="literal">NULL</span>;</span><br><span class="line">cgi_sapi_module.php_ini_ignore_cwd = <span class="number">1</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这一段主要是初始化 sapi 的代码，调用 sapi_startup 函数，传入 &amp;cgi_sapi_module。因为 fpm 实际上是一个 sapi 的 module, 而 sapi 的 module 是被定义好的一个数据结构，cgi_sapi_module 的初始化可以在 fpm_main.c 中找到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> sapi_module_struct cgi_sapi_module = &#123;</span><br><span class="line">    <span class="string">"fpm-fcgi"</span>,                        <span class="comment">/* name */</span></span><br><span class="line">    <span class="string">"FPM/FastCGI"</span>,                    <span class="comment">/* pretty name */</span></span><br><span class="line"></span><br><span class="line">    php_cgi_startup,                <span class="comment">/* startup */</span></span><br><span class="line">    php_module_shutdown_wrapper,    <span class="comment">/* shutdown */</span></span><br><span class="line"></span><br><span class="line">    sapi_cgi_activate,                <span class="comment">/* activate */</span></span><br><span class="line">    sapi_cgi_deactivate,            <span class="comment">/* deactivate */</span></span><br><span class="line"></span><br><span class="line">    sapi_cgibin_ub_write,            <span class="comment">/* unbuffered write */</span></span><br><span class="line">    sapi_cgibin_flush,                <span class="comment">/* flush */</span></span><br><span class="line">    <span class="literal">NULL</span>,                            <span class="comment">/* get uid */</span></span><br><span class="line">    sapi_cgibin_getenv,                <span class="comment">/* getenv */</span></span><br><span class="line"></span><br><span class="line">    php_error,                        <span class="comment">/* error handler */</span></span><br><span class="line"></span><br><span class="line">    <span class="literal">NULL</span>,                            <span class="comment">/* header handler */</span></span><br><span class="line">    sapi_cgi_send_headers,            <span class="comment">/* send headers handler */</span></span><br><span class="line">    <span class="literal">NULL</span>,                            <span class="comment">/* send header handler */</span></span><br><span class="line"></span><br><span class="line">    sapi_cgi_read_post,                <span class="comment">/* read POST data */</span></span><br><span class="line">    sapi_cgi_read_cookies,            <span class="comment">/* read Cookies */</span></span><br><span class="line"></span><br><span class="line">    sapi_cgi_register_variables,    <span class="comment">/* register server variables */</span></span><br><span class="line">    sapi_cgi_log_message,            <span class="comment">/* Log message */</span></span><br><span class="line">    <span class="literal">NULL</span>,                            <span class="comment">/* Get request time */</span></span><br><span class="line">    <span class="literal">NULL</span>,                            <span class="comment">/* Child terminate */</span></span><br><span class="line"></span><br><span class="line">    STANDARD_SAPI_MODULE_PROPERTIES</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看出 cgi_sapi_module 的数据类型是 sapi_module_struct，这个数据类型是 PHP 的 SAPI 中定义的，是类似于 OOP 中 class 的东西。而这个 sapi_startup 函数做的主要事情是分配互斥量(tsrm_mutex_alloc)。互斥量主要为针对多线程准备的，而 fastcgi 模式运行 PHP 都是单线程，所以不存在多线程中出现临界资源的使用问题。</p><p>在此之后的很长一部分代码都是处理命令行模式运行时的输入参数，这一段先略过，直接跳到 cgi_sapi_module 的 startup 部分：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* startup after we get the above ini override se we get things right */</span></span><br><span class="line">    <span class="keyword">if</span> (cgi_sapi_module.startup(&amp;cgi_sapi_module) == FAILURE) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ZTS</span></span><br><span class="line">        tsrm_shutdown();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span> FPM_EXIT_SOFTWARE;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>根据上面提到的 sapi_module_struct 的定义和 cgi_sapi_module 初始化的结果，不难看出 startup 调用的实际上是 fpm_main.c 中 php_cgi_startup 函数。而 php_cgi_startup 函数中主要做的事情就是调用 php 的 main.c 中定义的 php_module_startup 函数。像这种调用方式在 php 的实现中非常常见，保证了代码的鲁棒性。至于 php_module_startup 都干了哪些事情，后面再详细介绍，简而言之，该函数将会读取 php.ini 中的配置初始化 php 解释运行环境，主要包括：</p><ul><li>php 核心配置</li><li>zend 配置</li><li>php 扩展初始化及启动</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">php_cgi_startup</span><span class="params">(sapi_module_struct *sapi_module)</span> <span class="comment">/* &#123;&#123;&#123; */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (php_module_startup(sapi_module, &amp;cgi_module_entry, <span class="number">1</span>) == FAILURE) &#123;</span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到目前为止，需要的东西都初始化过了，该进入 fpm 的正题了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">0</span> &gt; fpm_init(argc, argv, fpm_config ? fpm_config : CGIG(fpm_config), fpm_prefix, fpm_pid, test_conf, php_allow_to_run_as_root, force_daemon, force_stderr)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fpm_globals.send_config_pipe[<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">int</span> writeval = <span class="number">0</span>;</span><br><span class="line">            zlog(ZLOG_DEBUG, <span class="string">"Sending \"0\" (error) to parent via fd=%d"</span>, fpm_globals.send_config_pipe[<span class="number">1</span>]);</span><br><span class="line">            zend_quiet_write(fpm_globals.send_config_pipe[<span class="number">1</span>], &amp;writeval, <span class="keyword">sizeof</span>(writeval));</span><br><span class="line">            close(fpm_globals.send_config_pipe[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> FPM_EXIT_CONFIG;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fpm_globals.send_config_pipe[<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">int</span> writeval = <span class="number">1</span>;</span><br><span class="line">        zlog(ZLOG_DEBUG, <span class="string">"Sending \"1\" (OK) to parent via fd=%d"</span>, fpm_globals.send_config_pipe[<span class="number">1</span>]);</span><br><span class="line">        zend_quiet_write(fpm_globals.send_config_pipe[<span class="number">1</span>], &amp;writeval, <span class="keyword">sizeof</span>(writeval));</span><br><span class="line">        close(fpm_globals.send_config_pipe[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    fpm_is_running = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    fcgi_fd = fpm_run(&amp;max_requests);</span><br><span class="line">    parent = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* onced forked tell zlog to also send messages through sapi_cgi_log_fastcgi() */</span></span><br><span class="line">    zlog_set_external_logger(sapi_cgi_log_fastcgi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* make php call us to get _ENV vars */</span></span><br><span class="line">    php_php_import_environment_variables = php_import_environment_variables;</span><br><span class="line">    php_import_environment_variables = cgi_php_import_environment_variables;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* library is already initialized, now init our request */</span></span><br><span class="line">    request = fpm_init_request(fcgi_fd);</span><br></pre></td></tr></table></figure><p>首先便是 <strong>fpm_init</strong>，然后是 <strong>fpm_run</strong>，最后是 <strong>fpm_init_request</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpm_init</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> *config, <span class="keyword">char</span> *prefix, <span class="keyword">char</span> *pid, <span class="keyword">int</span> test_conf, <span class="keyword">int</span> run_as_root, <span class="keyword">int</span> force_daemon, <span class="keyword">int</span> force_stderr)</span> <span class="comment">/* &#123;&#123;&#123; */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fpm_globals.argc = argc;</span><br><span class="line">    fpm_globals.argv = argv;</span><br><span class="line">    <span class="keyword">if</span> (config &amp;&amp; *config) &#123;</span><br><span class="line">        fpm_globals.config = strdup(config);</span><br><span class="line">    &#125;</span><br><span class="line">    fpm_globals.prefix = prefix;</span><br><span class="line">    fpm_globals.pid = pid;</span><br><span class="line">    fpm_globals.run_as_root = run_as_root;</span><br><span class="line">    fpm_globals.force_stderr = force_stderr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt; fpm_php_init_main()           ||</span><br><span class="line">        <span class="number">0</span> &gt; fpm_stdio_init_main()         ||</span><br><span class="line">        <span class="number">0</span> &gt; fpm_conf_init_main(test_conf, force_daemon) ||</span><br><span class="line">        <span class="number">0</span> &gt; fpm_unix_init_main()          ||</span><br><span class="line">        <span class="number">0</span> &gt; fpm_scoreboard_init_main()    ||</span><br><span class="line">        <span class="number">0</span> &gt; fpm_pctl_init_main()          ||</span><br><span class="line">        <span class="number">0</span> &gt; fpm_env_init_main()           ||</span><br><span class="line">        <span class="number">0</span> &gt; fpm_signals_init_main()       ||</span><br><span class="line">        <span class="number">0</span> &gt; fpm_children_init_main()      ||</span><br><span class="line">        <span class="number">0</span> &gt; fpm_sockets_init_main()       ||</span><br><span class="line">        <span class="number">0</span> &gt; fpm_worker_pool_init_main()   ||</span><br><span class="line">        <span class="number">0</span> &gt; fpm_event_init_main()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fpm_globals.test_successful) &#123;</span><br><span class="line">            <span class="built_in">exit</span>(FPM_EXIT_OK);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            zlog(ZLOG_ERROR, <span class="string">"FPM initialization failed"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt; fpm_conf_write_pid()) &#123;</span><br><span class="line">        zlog(ZLOG_ERROR, <span class="string">"FPM initialization failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fpm_stdio_init_final();</span><br><span class="line">    zlog(ZLOG_NOTICE, <span class="string">"fpm is running, pid %d"</span>, (<span class="keyword">int</span>) fpm_globals.parent_pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难看出，<strong>fpm_init</strong> 返回 -1 时，整个程序将会退出，当有错误发生但是 fpm_globals 中标记了 test_successful 时，会使用 exit(0) 退出，因为配置文件没有错误，而成功时会返回 0。</p><p>fpm 初始化的过程分 13 步，分别是:</p><ul><li>fpm_php_init_main() <strong>注册进程清理方法</strong></li><li>fpm_stdio_init_main() <strong>验证 /dev/null 是否可读写</strong></li><li>fpm_conf_init_main(test_conf, force_daemon) <strong>校验并加载配置文件</strong></li><li>fpm_unix_init_main() <strong>检查 unix 运行环境</strong></li><li>fpm_scoreboard_init_main() <strong>初始化“进程记分牌”</strong></li><li>fpm_pctl_init_main() <strong>进程管理相关初始化</strong></li><li>fpm_env_init_main() <strong>？</strong></li><li>fpm_signals_init_main() <strong>设置信号处理方式</strong></li><li>fpm_children_init_main() <strong>初始化子进程，注册进程清理方法</strong></li><li>fpm_sockets_init_main() <strong>初始化 sockets</strong></li><li>fpm_worker_pool_init_main() <strong>注册 worker pool 清理方法</strong></li><li>fpm_event_init_main() <strong>注册 event 清理方法</strong></li></ul><p>可以说相当复杂的一个过程，只要有一个函数无法返回 0，程序将直接退出。在完成这一系列的操作之后，fpm 会向配置文件中指定的 pid 文件写入 master 进程id。整个过程其实是为了启动 php-fpm 进程做初始化的工作，到这一步 php-fpm 还是无法接收请求的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">0</span> &gt; fpm_conf_write_pid()) &#123;</span><br><span class="line">  zlog(ZLOG_ERROR, <span class="string">"FPM initialization failed"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> php7 阅读源码 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>按分组选出值最大的n行数据</title>
      <link href="/2017/05/18/select-max-top-n-rows-with-groupby/"/>
      <url>/2017/05/18/select-max-top-n-rows-with-groupby/</url>
      <content type="html"><![CDATA[<p>介绍几种选出值最大的n行数据的方法<br><a id="more"></a></p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>有一张表，结构如下：id为自增主键，innodb 引擎</p><table><thead><tr><th>id（PK,AI)</th><th>product_id</th><th>product_name</th><th>product_price</th><th>shop_id（FK)</th></tr></thead><tbody><tr><td>1000</td><td>23134</td><td>‘bread’</td><td>2.30</td><td>13421</td></tr><tr><td>1001</td><td>23135</td><td>‘beaf’</td><td>7.30</td><td>13421</td></tr><tr><td>1002</td><td>23154</td><td>‘apple’</td><td>3.30</td><td>13421</td></tr><tr><td>1003</td><td>39134</td><td>‘rice’</td><td>1.30</td><td>13422</td></tr><tr><td>1004</td><td>73234</td><td>‘chicken’</td><td>4.30</td><td>13422</td></tr><tr><td>1005</td><td>832134</td><td>‘orange’</td><td>2.50</td><td>13422</td></tr><tr><td>1006</td><td>75139</td><td>‘banana’</td><td>6.30</td><td>13423</td></tr><tr><td>1007</td><td>52128</td><td>‘melon’</td><td>1.20</td><td>13423</td></tr><tr><td>1008</td><td>21114</td><td>‘strawberry’</td><td>4.90</td><td>13423</td></tr></tbody></table><p>DDL 如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`product`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`product_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`product_name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">  <span class="string">`product_price`</span> <span class="built_in">float</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`shop_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`index2`</span> (<span class="string">`product_id`</span>,<span class="string">`shop_id`</span>,<span class="string">`product_price`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">11</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure></p><p>测试数据：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test.product (product_id, product_name, product_price, shop_id) <span class="keyword">VALUES</span> (<span class="number">29</span>, <span class="string">'prod_1.2'</span>, <span class="number">1.2</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test.product (product_id, product_name, product_price, shop_id) <span class="keyword">VALUES</span> (<span class="number">12</span>, <span class="string">'prod_2.2'</span>, <span class="number">2.2</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test.product (product_id, product_name, product_price, shop_id) <span class="keyword">VALUES</span> (<span class="number">14</span>, <span class="string">'prod_200_1.5'</span>, <span class="number">1.5</span>, <span class="number">200</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test.product (product_id, product_name, product_price, shop_id) <span class="keyword">VALUES</span> (<span class="number">15</span>, <span class="string">'prod_200_11.5'</span>, <span class="number">11.5</span>, <span class="number">200</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test.product (product_id, product_name, product_price, shop_id) <span class="keyword">VALUES</span> (<span class="number">16</span>, <span class="string">'prod_200_12.3'</span>, <span class="number">12.3</span>, <span class="number">200</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test.product (product_id, product_name, product_price, shop_id) <span class="keyword">VALUES</span> (<span class="number">17</span>, <span class="string">'prod_300_220.1'</span>, <span class="number">220.1</span>, <span class="number">300</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test.product (product_id, product_name, product_price, shop_id) <span class="keyword">VALUES</span> (<span class="number">18</span>, <span class="string">'prod_300_100.2'</span>, <span class="number">100.2</span>, <span class="number">300</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test.product (product_id, product_name, product_price, shop_id) <span class="keyword">VALUES</span> (<span class="number">19</span>, <span class="string">'prod_300_300'</span>, <span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test.product (product_id, product_name, product_price, shop_id) <span class="keyword">VALUES</span> (<span class="number">21</span>, <span class="string">'prod_100_120'</span>, <span class="number">120</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test.product (product_id, product_name, product_price, shop_id) <span class="keyword">VALUES</span> (<span class="number">91</span>, <span class="string">'prod_400_1.2'</span>, <span class="number">1.2</span>, <span class="number">400</span>);</span><br></pre></td></tr></table></figure></p><h2 id="第一个问题：查出每个店铺价格最贵的商品"><a href="#第一个问题：查出每个店铺价格最贵的商品" class="headerlink" title="第一个问题：查出每个店铺价格最贵的商品"></a>第一个问题：查出每个店铺价格最贵的商品</h2><p>这个问题非常简单，因为 MySQL 有一个 Max 函数可以计算出最大的值，并按照 shop_id group 即可：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  product_id, product_name, shop_id, <span class="keyword">MAX</span>(product_price)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    product</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> shop_id;</span><br></pre></td></tr></table></figure></p><p><strong>要是真这么以为的话，那就要铸成大错了！</strong>这里有一个误区，MAX 函数和 group by 配合使用确实能计算出每个商店最贵的商品，但是其他列的数据理论上是和这个最大值无关的，如果结果正确了，一定是因为巧合！</p><p>说到这里，就顺带记录一下一条查询（select）语句中各个关键字执行的顺序：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(8) <span class="keyword">SELECT</span> (<span class="number">9</span>) <span class="keyword">DISTINCT</span>&lt;select_list&gt;</span><br><span class="line">(<span class="number">1</span>) <span class="keyword">FROM</span> &lt;left_table&gt;</span><br><span class="line">(<span class="number">3</span>) &lt;join_type&gt; <span class="keyword">JOIN</span> &lt;right_table&gt;</span><br><span class="line">(<span class="number">2</span>) <span class="keyword">ON</span> &lt;join_condition&gt;</span><br><span class="line">(<span class="number">4</span>) <span class="keyword">WHERE</span> &lt;where_condition&gt;</span><br><span class="line">(<span class="number">5</span>) <span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;group_by_list&gt;</span><br><span class="line">(<span class="number">6</span>) <span class="keyword">WITH</span></span><br><span class="line">(<span class="number">7</span>) <span class="keyword">HAVING</span></span><br><span class="line">(<span class="number">10</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;order_by&gt;</span><br><span class="line">(<span class="number">11</span>) <span class="keyword">LIMIT</span></span><br></pre></td></tr></table></figure></p><p><code>GROUP BY</code> 是先于 <code>SELECT</code> 执行的，而 <code>MAX</code> 函数会根据 <code>GROUP BY</code> 的条件去对结果进行聚合计算出按照该列分类的每一类中的最大值，其他列与这个值并不具备相关性，也无法做到相关性。所以上面那个是错误的。</p><p>一种思路是这样的：先将 shop_id 和 max(product_price) 选出来，再根据结果与表自身做一次连接，连接条件就是 shop_id 和 product_price。SQL 如下，<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    p2.*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    (<span class="keyword">SELECT</span></span><br><span class="line">        shop_id, <span class="keyword">MAX</span>(product_price) <span class="keyword">AS</span> product_price</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">        product p1</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> shop_id) <span class="keyword">AS</span> p1</span><br><span class="line">        <span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">    product p2 <span class="keyword">ON</span> p2.shop_id = p1.shop_id</span><br><span class="line">        <span class="keyword">AND</span> p2.product_price = p1.product_price</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> p2.id;</span><br></pre></td></tr></table></figure></p><p><img src="https://raw.githubusercontent.com/lephp/lephp.github.io/master/images/201705/select-max-value-1-no-index.png" alt="执行计划(未添加索引)"></p><p><img src="https://raw.githubusercontent.com/lephp/lephp.github.io/master/images/201705/select-max-value-solution-1-indexed.png" alt="执行计划(已添加索引)"></p><p>还有一种思路是：使用关联子查询，这种方式比上一种的效率要高很多，子查询将每个商店的最大值取出来，放入主查询的 where 条件，SQL 如下，<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    product</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    product_price <span class="keyword">IN</span> (<span class="keyword">SELECT</span></span><br><span class="line">            <span class="keyword">MAX</span>(product_price)</span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">            product</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> shop_id)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">id</span>;</span><br></pre></td></tr></table></figure></p><p><img src="https://raw.githubusercontent.com/lephp/lephp.github.io/master/images/201705/select-max-value-solution-2-no-index.png" alt="执行计划(未添加索引)"></p><p><img src="https://raw.githubusercontent.com/lephp/lephp.github.io/master/images/201705/select-max-value-solution-2-indexed.png" alt="执行计划(已添加索引)"></p><p>很显然第二种方式的查询效率更高，至于怎么建立索引，我这里选取了 shop_id 和 product_price 两个字段建立BTREE联合索引，而索引选择的原则我现在还不是很有经验，只是凭直觉，从 EXPLAIN 的结果上看的话，还是不错的。</p><h2 id="第二个问题：每个店铺价格最贵的-2-件商品"><a href="#第二个问题：每个店铺价格最贵的-2-件商品" class="headerlink" title="第二个问题：每个店铺价格最贵的 2 件商品"></a>第二个问题：每个店铺价格最贵的 2 件商品</h2><p>看到这个题目，我第一反应是，要按照每个店铺去聚集计算出最大的两行，然后再使用 union join 把所有结果合并起来，显然这种做法缺乏灵活性，如果我有一千个商铺，那岂不是要有999个 union join…ヽ(*。&gt;Д&lt;)o゜可怕！</p><p>上面第一题中使用 <code>product_price</code> 与子查询做连接查出最贵的，同样可以查出第二贵的商品，具体实现 SQL 如下，</p><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法 1"></a>解法 1</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  <span class="string">`product`</span> p1</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  <span class="string">`product_price`</span> = (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(<span class="string">`product_price`</span>)</span><br><span class="line">                     <span class="keyword">FROM</span></span><br><span class="line">                       <span class="string">`product`</span> p2</span><br><span class="line">                     <span class="keyword">WHERE</span></span><br><span class="line">                       <span class="string">`p2`</span>.<span class="string">`shop_id`</span> = <span class="string">`p1`</span>.<span class="string">`shop_id`</span>)</span><br><span class="line">  <span class="keyword">OR</span> <span class="string">`product_price`</span> = (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(<span class="string">`product_price`</span>)</span><br><span class="line">      <span class="keyword">FROM</span></span><br><span class="line">        <span class="string">`product`</span> p3</span><br><span class="line">      <span class="keyword">WHERE</span> <span class="string">`p3`</span>.shop_id = <span class="string">`p1`</span>.shop_id <span class="keyword">AND</span></span><br><span class="line">            <span class="string">`p3`</span>.<span class="string">`product_price`</span> &lt; (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(product_price)</span><br><span class="line">                                    <span class="keyword">FROM</span></span><br><span class="line">                                      <span class="string">`product`</span> p4</span><br><span class="line">                                    <span class="keyword">WHERE</span></span><br><span class="line">                                      <span class="string">`p4`</span>.<span class="string">`shop_id`</span> = <span class="string">`p3`</span>.<span class="string">`shop_id`</span>)</span><br><span class="line">      <span class="keyword">GROUP</span> <span class="keyword">BY</span> p3.shop_id)</span><br></pre></td></tr></table></figure><p>结构还是很清晰的，先查出最高的和第二高的，不过这种解法并不是很优雅：<br><img src="https://raw.githubusercontent.com/lephp/lephp.github.io/master/images/201705/select-max-n-value-solution-1-indexed.png" alt="执行计划"></p><p>一共使用了三个 <code>DEPENDENCY SUBQUERY</code>，可以说是非常复杂的。而且当需求一变，这个 SQL 就无效了，我个人认为使用频次高的查询要尽量具有通用性，这样在性能优化的时候也具有更大的操作空间。</p><p>TOP N 条记录，用子查询怎么解决？</p><h3 id="解法-2-1"><a href="#解法-2-1" class="headerlink" title="解法 2-1"></a>解法 2-1</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="string">`p1`</span>.*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    <span class="string">`product`</span> p1</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    <span class="number">2</span> &gt; (<span class="keyword">SELECT</span></span><br><span class="line">            <span class="keyword">COUNT</span>(*)</span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">            <span class="string">`product`</span> p2</span><br><span class="line">        <span class="keyword">WHERE</span></span><br><span class="line">            <span class="string">`p2`</span>.<span class="string">`shop_id`</span> = <span class="string">`p1`</span>.<span class="string">`shop_id`</span></span><br><span class="line">                <span class="keyword">AND</span> <span class="string">`p2`</span>.<span class="string">`product_price`</span> &gt; <span class="string">`p1`</span>.<span class="string">`product_price`</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`p1`</span>.<span class="string">`shop_id`</span> , <span class="string">`p1`</span>.<span class="string">`product_price`</span> <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>上述解法的核心理念是用一个关联子查询查出 <code>product_price</code> 列的所有值中，值比其大的行总数小于2(或者n)的所有行，子查询与表达式作为 where 条件返回 <code>TRUE</code> 或者 <code>FALSE</code>，最后返回的是返回 <code>TRUE</code> 的所有行。</p><p>更通俗一点解释，要查最大的两行，遍历到其中一行的时候，将其和表中每一行对应的列的值做一一比较，总数小于2的话，那说明它是最大的两个值之一，所以就命中选择条件。</p><p>这种思路还可以这么写，使用 <code>HAVING</code> 来控制 <code>TRUE/FALSE</code></p><h3 id="解法-2-2"><a href="#解法-2-2" class="headerlink" title="解法 2-2"></a>解法 2-2</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="string">`p1`</span>.*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    <span class="string">`test`</span>.<span class="string">`product`</span> p1</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    <span class="keyword">EXISTS</span>( <span class="keyword">SELECT</span></span><br><span class="line">            <span class="keyword">COUNT</span>(*)</span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">            <span class="string">`test`</span>.<span class="string">`product`</span> p2</span><br><span class="line">        <span class="keyword">WHERE</span></span><br><span class="line">            <span class="string">`p2`</span>.<span class="string">`shop_id`</span> = <span class="string">`p1`</span>.<span class="string">`shop_id`</span></span><br><span class="line">                <span class="keyword">AND</span> <span class="string">`p2`</span>.<span class="string">`product_price`</span> &gt; <span class="string">`p1`</span>.<span class="string">`product_price`</span></span><br><span class="line">        <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &lt; <span class="number">2</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`p1`</span>.<span class="string">`shop_id`</span>, <span class="string">`p1`</span>.<span class="string">`product_price`</span> <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> MySQL SQL groupby </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTTP POST 表单提交方式介绍</title>
      <link href="/2017/05/17/http-post-methods-comparison/"/>
      <url>/2017/05/17/http-post-methods-comparison/</url>
      <content type="html"><![CDATA[<p>为客户端提供接口的时候，发现客户端对于 http 接口的调用方式不是很清楚，介绍 HTTP POST 请求的几种常用的 Content-Type。<br><a id="more"></a><br>HTTP 1.1 <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17" target="_blank" rel="noopener">RFC-2616</a> 协议中 Content-Type 的定义是：</p><blockquote><p>The Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET.</p></blockquote><p>它被放置在 header 中，表示发送的请求 Body 中的数据格式。</p><h2 id="multipart-form-data"><a href="#multipart-form-data" class="headerlink" title="multipart/form-data"></a>multipart/form-data</h2><p><code>multipart/form-data</code> 在 web 领域经常被用于表单提交，被提交的数据一般是一个完整的 <code>Model</code>，例如登录注册的表单的场景。</p><h2 id="application-octet-stream"><a href="#application-octet-stream" class="headerlink" title="application/octet-stream"></a>application/octet-stream</h2><h2 id="x-www-form-urlencoded"><a href="#x-www-form-urlencoded" class="headerlink" title="x-www-form-urlencoded"></a>x-www-form-urlencoded</h2><h2 id="raw"><a href="#raw" class="headerlink" title="raw"></a>raw</h2><h2 id="binary"><a href="#binary" class="headerlink" title="binary"></a>binary</h2>]]></content>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2017 面试记录</title>
      <link href="/2017/05/17/2017-interviews/"/>
      <url>/2017/05/17/2017-interviews/</url>
      <content type="html"><![CDATA[<p>找工作呀找工作…<br><a id="more"></a></p><h2 id="今日头条"><a href="#今日头条" class="headerlink" title="今日头条"></a>今日头条</h2><p>头条工作环境确实不错，约的上午10点半，前台安排到一个面试间，然后等了大概20分钟左右面试官来了，看起来挺技术范儿的一哥们儿。</p><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>一面主要讲了一些项目上的经历，让挑一个自己觉得不错的项目讲了一下，挑的是在微博做的一个项目，然后里面因为提到做了一些性能优化的事情，就深入问了一些数据库优化方面的知识，结合一些具体的应用场景，比如大的报表导出的性能优化方向，主要就是一些索引的选择、联表查询的优化上。然后问了一下<strong>B+树和SQL执行的过程</strong>，没好好准备，答的比较粗。</p><p>然后就是另外一个并发量比较高的项目，介绍了整个性能优化的过程，这一块因为是去年底刚刚做的，所以记忆还比较深刻。在提到opcache的时候顺带把自己写的opcache源码分析给面试官看了一下，应该印象还不错，面试官也发表了一些自己的看法。然后他对我们使用PHP7还比较惊讶。</p><p>最后面试官让写了一道算法题，两个有序数组的合并。刚开始有点紧张，不过后来在纸上写出来了，常考不难的题目。</p><ul><li>redis+mysql 的数据一致性问题怎么解决</li><li>B+树</li><li>SQL 执行过程</li><li>数据库性能优化</li><li>对 MVC 分层的理解，对设计模式的使用</li></ul><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>二面的面试官好像不太看我的简历上的东西了，主要出了下面几个题目：</p><ul><li>手写SQL, 查询每个店铺最贵的N个商品，降序排列</li><li>MySQL 性能优化的方法，涉及 SQL 执行过程分析，Explain 结果分析，还出了个SQL语句问有没有用到索引</li><li>算法题：全排列，用递归写了，然后要求用非递归实现</li><li>数据库的四种隔离级别</li><li>数据库锁的原理，SELECT … FOR UPDATE 和 SELECT … 的区别，上的什么锁，锁之间的互斥关系</li><li>varchar(50) int(4) char(50) 里面数字分别的含义</li><li>解释脏读、幻读</li><li>PHP 生命周期</li><li>Top 命令各项数据的解释</li><li>socket 建立连接每一步的客户端和服务端状态</li><li>syn 泛洪攻击</li><li>opcache 缓存过期策略</li><li>redis 的事务</li></ul><p>通过头条这次面试还是能发现很多薄弱环节，对一些知识的理解浮于表面，没有深入去细看，所以导致有些问题答的比较犹豫、粗，接下来还是认真去怼一些应该知道的东西的细节，不能太浮躁，知识积累是很漫长的过程，像数据库的一些细节是需要深入了解细节才能加深理解的，实际使用的过程中虽然看起来没有遇到问题，但是只要流量大了，很多细节不注意就会被放大到影响业务的正常运转。</p><p>另外一个问题是自己的表达能力还是很欠缺的，很多问题我其实想的挺清楚，但是表达起来语言组织能力感觉很差，容易让面试官听不懂，不知道是不是太紧张的原因。</p><h2 id="美图"><a href="#美图" class="headerlink" title="美图"></a>美图</h2><p>美图北京在搜狐网络大厦，不错的写字楼，高峰期电梯也没有特别的多人。</p><h3 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h3><p>笔试题比较少，就5道题</p><ul><li>观察者模式（对象属性变化通知）</li><li>global 的使用</li><li>缓存被击穿了，怎么办</li><li>设计日志收集系统</li><li>设计大型文章推荐系统架构</li></ul><h3 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h3><ul><li>PSR4 与 PSR0 区别</li><li>autoload 和 spl_autoload 的区别</li></ul><h3 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h3><p>聊的基本都是上面的问题，问题也比较开放，我自己还是老问题依然存在：知识点没吃透。具体一点的话，对设计模式的理解和运用还不熟练，对于缓存和落地之间的配合和紧急故障处理的方式上回答的也不够果断和富有经验。不过面试官也比较直白的说了我还是缺乏大型项目经验，再加上我的期望薪资写的比较高，确实是很高，不过我心里是给他们砍价的空间的，连砍价都不砍，那估计是真的太高了吧。一面挂，没啥更多的可以说，认真结合自己的情况和职业发展的期望分析，还是希望接下来能够有机会去 BAT 这种平台多磨练两年。继续加油吧！</p>]]></content>
      
      
        <tags>
            
            <tag> interviews </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>OPCache 工作机制</title>
      <link href="/2016/12/18/things-about-opcache/"/>
      <url>/2016/12/18/things-about-opcache/</url>
      <content type="html"><![CDATA[<p>基于 PHP7 源码分析 opcache 内部工作机制<br><a id="more"></a></p><h1 id="一个请求的-np-Nginx-PHP-之旅"><a href="#一个请求的-np-Nginx-PHP-之旅" class="headerlink" title="一个请求的 np (Nginx - PHP) 之旅"></a>一个请求的 np (Nginx - PHP) 之旅</h1><ol><li>Nginx 监听 80 端口，接到请求后，通过 socket 将请求发到其 worker 上；</li><li>Worker 根据 Nginx 配置再将请求发到 php-fpm 管理的的进程池中；</li><li>php-fpm 根据请求调用 php-cgi 执行 php 脚本；</li><li>执行完的结果会被返回给 nginx。</li></ol><p><img src="https://raw.githubusercontent.com/lephp/lephp.github.io/master/images/Nginx-PHP-Workflow.png" alt="nginx php workflow"></p><p>因为本文主要是讲 php 执行过程中 opcache 的作用，所以上面四个步骤暂时只需要关注第3点。</p><h2 id="两个概念"><a href="#两个概念" class="headerlink" title="两个概念"></a>两个概念</h2><h3 id="php-fpm"><a href="#php-fpm" class="headerlink" title="php-fpm"></a>php-fpm</h3><p>全称：php-fastcgi process manager, 主要干几件事</p><ul><li>管理 php-cgi 进程</li><li>管理 php-cgi 进程</li><li>管理 php-cgi 进程</li></ul><h3 id="php-cgi"><a href="#php-cgi" class="headerlink" title="php-cgi"></a>php-cgi</h3><p>全称：php-cgi, php 有两种运行方式，cli 和 cgi, cli 就是命令行执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/bin/php -f a.php</span><br></pre></td></tr></table></figure><p>cgi 就是所谓的 Common Gateway Interface（通用网关接口），详细可以去翻一下 《HTTP 权威指南》，php-cgi 就是用于提供给网站的 php 解释器。</p><h1 id="一次完整的脚本执行过程"><a href="#一次完整的脚本执行过程" class="headerlink" title="一次完整的脚本执行过程"></a>一次完整的脚本执行过程</h1><p>这是一个标准的脚本语言干的事情：</p><ol><li>词法分析 + 语法分析 =&gt; 生成语法树</li><li>通过语法树 =&gt; 生成操作码</li><li>按操作码的顺序一步一步执行</li><li>输出结果</li></ol><p><img src="https://raw.githubusercontent.com/lephp/lephp.github.io/master/images/php-execute-process.png" alt="php execute process"></p><p>每次请求过来php都会通过如上四步来处理请求，每次都是。但是实际业务运转中，很多流程其实是完全一样的，甚至连变量的值都一样，然而，解释编译过程仍然会去读取相同的代码来一遍，不禁想起一句话：</p><blockquote><p>越是简单重复的工作越能体现出制作者的心意</p></blockquote><p>能更快的把客户需要的东西送到他们手上也很重要！毫无疑问，这个过程中存在对资源的极大浪费，我们都知道词法的分析和解释以及编译都是极其消耗计算资源的过程，于是乎，用于缓存 OPCodes 的扩展应运而生。它只有一个目标，<strong>每个 PHP 脚本只被编译一次</strong>，然后将生成的 OPCodes 存储到共享内存区中，如此，其他的 php-fpm 进程都可以访问并使用共享缓存区中的 OPCodes。</p><p>这个方法能给 PHP 脚本的执行速度提升两倍以上！实际运用中，对于 include 几十几百个脚本的大型网站，其速度提升会超过 10 倍，这是因为 PHP 的编译器很慢，因为它需要将一堆具有语义的编程语言转换成机器能执行的操作码，尝试去理解产品经理的需求，并且要在保证安全和正确的前提下尽量生成流程最优的操作码序列。</p><p>PHP 中用于缓存 OPCodes 的扩展主要有：</p><ul><li>APC</li><li>XCache</li><li>Eaccelerator</li><li>OPCache（Zend Optimizer+)</li><li>…</li></ul><p>APC 可能很多 PHP 程序员用过或者正在用，但是 APC 已经不再更新很久了，如果可以，升级到 PHP7 吧！为了世界和平！ 更详细的信息可以在 <a href="https://en.wikipedia.org/wiki/List_of_PHP_accelerators" target="_blank" rel="noopener"><strong>Wikipedia:List of PHP accelerators</strong></a> 找到，这里就不做对比了，本文主要研究 OPCache。</p><h1 id="OPCache-简介"><a href="#OPCache-简介" class="headerlink" title="OPCache 简介"></a>OPCache 简介</h1><p>opcache 原称：Zend Optimizer+ ，是 Zend Server 的一个开源组件，在2013年3月中旬之后更名为 Zend Opcache。它从 PHP 5.5 开始就随着 PHP 一起发行，但是必须要在 php.ini 中打开才可以生效，它主要提供两个优化方向：</p><ul><li>OPCodes 和 Interned Strings 的缓存（用于进程间共享）</li><li>OPCodes 优化</li></ul><p>OPCache 触发 PHP 编译器启动，获取 OPCodes 然后将其缓存起来，所以在这个过程中同样可以做另外一件事：代码优化。</p><h1 id="OPCodes-和-Interned-Strings-的缓存"><a href="#OPCodes-和-Interned-Strings-的缓存" class="headerlink" title="OPCodes 和 Interned Strings 的缓存"></a>OPCodes 和 Interned Strings 的缓存</h1><p>让我们深入研究一下 opcache 的工作原理, 它的源代码在这里：<br> <a href="https://github.com/php/php-src/tree/PHP-7.0/ext/opcache" target="_blank" rel="noopener">php-src/ext/opcache</a></p><h2 id="共享内存模型"><a href="#共享内存模型" class="headerlink" title="共享内存模型"></a>共享内存模型</h2><p>前面提到了缓存的机制主要是将编译好的操作码放入共享内存提供给其他进程访问，UNIX 系统提供很多种进程间内存共享的方式，常用的有：</p><ul><li>System-V shm API</li><li>POSIX API</li><li>mmap API</li></ul><p>OPCache 会根据系统支持的情况选择合适的接口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择共享内存模型</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> zend_shared_memory_handler_entry handler_table[] = &#123;</span><br><span class="line">#ifdef USE_MMAP</span><br><span class="line">    &#123; <span class="string">"mmap"</span>, &amp;zend_alloc_mmap_handlers &#125;,</span><br><span class="line">#endif</span><br><span class="line">#ifdef USE_SHM</span><br><span class="line">    &#123; <span class="string">"shm"</span>, &amp;zend_alloc_shm_handlers &#125;,</span><br><span class="line">#endif</span><br><span class="line">#ifdef USE_SHM_OPEN</span><br><span class="line">    &#123; <span class="string">"posix"</span>, &amp;zend_alloc_posix_handlers &#125;,</span><br><span class="line">#endif</span><br><span class="line">#ifdef ZEND_WIN32</span><br><span class="line">    &#123; <span class="string">"win32"</span>, &amp;zend_alloc_win32_handlers &#125;,</span><br><span class="line">#endif</span><br><span class="line">    &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个配置项可用于配置首选共享内存模型，如果没有设置这个值，OPCache 会选择系统第一个可以使用的模型。</p><blockquote><p>opcache.preferred_memory_model // 用于设置首选共享内存模型</p></blockquote><p>OPCache 默认会使用的是 mmap, 它是一种很常见的内存模型, 详细可以参考 《UNIX 环境高级编程》。 在 OPCache 启动之后，它会从系统中申请一块内存用作共享内存，大小取决于 php.ini 中 <strong>opcache.memory_consumption</strong> 配置的内存大小，它只会申请一次，不会释放，不会碎片化 （稍后会提到为什么），建议配置 opcache.memory_consumption 时不要吝啬，因为对于 PHP 实现的 网站来说，应该绝大多数不需要超过 1GB 内存。OPCache 申请这些内存用来存放下列内容和数据：</p><ul><li>脚本数据结构，包含且不限于 OPCode 的缓存</li><li>Interned Strings</li><li>脚本的哈希表</li><li>全局 OPCache 共享内存的状态</li><li>…</li></ul><p>也就是说，这部分内存不仅仅用于存储可复用的操作码序列，而且会有一些 OPCache 自身需要的东西在里面， 并且每部分占用的比例是可以设置的。</p><p>先分别来看一下 OPCodes 缓存和 Interned Strings 共享：</p><h2 id="OPCodes-缓存-操作码缓存"><a href="#OPCodes-缓存-操作码缓存" class="headerlink" title="OPCodes 缓存(操作码缓存)"></a>OPCodes 缓存(操作码缓存)</h2><p>文章刚开始的时候介绍了 Nginx 监听 80 端口，接到请求后，通过 socket 将请求发到其 worker 上，而这个 worker 就是 php-fpm 的子进程，每个请求都对应一个 php-fpm 进程，看一下请求一个包含 FPM 简要启动过程的请求执行流程图（到 zend_compile_file())：</p><p><img src="https://raw.githubusercontent.com/lephp/lephp.github.io/master/images/FPM-START-TO-PHP-REQUEST-START.png" alt="php request startup"></p><p>简单解释一下这个过程，当用户启动 php-fpm 的时候，它会根据配置初始化各种依赖，准备好各种资源，然后根据配置启动一定数量的子进程，这些子进程就是用于处理请求的，主进程本身不处理请求，主进程只需要负责根据配置统一初始化好进程资源（包括 PHP 编译执行环境），fork() 出子进程出来，进入等待状态，一旦有请求进来，php-fpm 进程就会进入 php 脚本的执行过程。</p><p>从图中可以看出，当 php-fpm 启动的时候，会将 php 的环境准备好再接受请求，所以，当 php.ini 文件中打开了 opcache 扩展的情况下，执行 php 脚本开始前 opcache 扩展已经启动了。</p><p>下面就详细介绍 opcache 扩展启动的过程已经工作原理：</p><p>所有本文中所介绍的东西都基于一个基本法：<strong>将处理每个请求过程中作用相同的指针以及不会发生变化的内容全部存入共享内存</strong>。</p><p>针对相同的请求，PHP 编译器将从共享内存中直接取出编译好的操作码序列（op_array），绑定到当前处理该请求的 php-fpm 子进程中。PHP 编译器工作的时使用 Zend Memory Manager(ZMM) 来分配指针。 这种内存使用方式是和请求绑定的，每次请求结束之后 ZMM 会主动释放这些内存空间。很显然这些被分配的指针地址是在当前进程的堆栈中，并且不可以被其他进程所共享的。因此 OPCache 的工作就是把每个 PHP 编译器返回的数据结构都检查一遍，然后把他们都拷贝到一个共享存储区中。</p><p>这里提到的编译过程中所有被编译器所处理的东西都是不可变的，也就是”常量”。可变的数据会在运行时由 Zend Virtual Machine 创建，所以我们认为保存所有被编译器所处理过的数据到共享内存中都是安全的，因为它们不会再将来发生变化。</p><p>这些被保存的东西包括：函数、类、函数的指针、函数的操作码数组指针、类的常量，类中被声明的变量名和它们最终的默认值等等，后面将会详细介绍。</p><p>这样的内存模型是为了在最大程度上避免出现资源锁，后文中将会详细介绍锁的相关内容。有一个很基本的 OPCache 只在运行之前工作一次，而在运行过程中，OPCache 则是个安静的美男子：ZMM 会在进程的堆栈中 创建变量，而常量则直接从 OPCache 提供的共享内存中取。</p><p>那 OPCache 怎么做到这一点呢？它其实是通过钩子的方式将自己注入到编译器中，替代编译 PHP 脚本 过程中需要填充的数据结构，让编译器初始化一个 persistent_script 的结构并且赋值来替代 Zend Engine 表和其他内部结构。</p><p>下面是 persistent_script 的结构定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_persistent_script</span> &#123;</span></span><br><span class="line">    ulong          hash_value;</span><br><span class="line">    <span class="keyword">char</span>          *full_path;              <span class="comment">/* 绝对连接，并且软连接也是被解析过了 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>   full_path_len;</span><br><span class="line">    zend_op_array  main_op_array;          <span class="comment">/* opcode array ，操作码序列 */</span></span><br><span class="line">    HashTable      function_table;</span><br><span class="line">    HashTable      class_table;</span><br><span class="line">    <span class="keyword">long</span>           compiler_halt_offset;   <span class="comment">/* position of __HALT_COMPILER or -1 */</span></span><br><span class="line">    <span class="keyword">int</span>            ping_auto_globals_mask; <span class="comment">/* which autoglobals are used by the script */</span></span><br><span class="line">    <span class="keyword">accel_time_t</span>   timestamp;              <span class="comment">/* 脚本修改时间戳 */</span></span><br><span class="line">    zend_bool      corrupted;             <span class="comment">/* 是否过期 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ZEND_EXTENSION_API_NO &lt; PHP_5_3_X_API_NO</span></span><br><span class="line">    zend_uint      early_binding;          <span class="comment">/* the linked list of delayed declarations */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>          *mem;                    <span class="comment">/* shared memory area used by script structures */</span></span><br><span class="line">    <span class="keyword">size_t</span>         size;                   <span class="comment">/* size of used shared memory */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* All entries that shouldn't be counted in the ADLER32</span></span><br><span class="line"><span class="comment">     * checksum must be declared in this struct</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zend_persistent_script_dynamic_members</span> &#123;</span></span><br><span class="line">        <span class="keyword">time_t</span>       last_used;</span><br><span class="line">        ulong        hits;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> memory_consumption;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> checksum;</span><br><span class="line">        <span class="keyword">time_t</span>       revalidate;</span><br><span class="line">    &#125; dynamic_members;</span><br><span class="line">&#125; zend_persistent_script;</span><br></pre></td></tr></table></figure><p>当服务器第一次接到请求时，共享内存中是没有任何东西的，这时候 <strong>zend_accel_hash_str_find</strong> 肯定取不到任何东西，所以需要按照 OPCache 需要的配置去调用编译器编译出一份 persistent_script 结构，然后调用 <strong>cache_script_in_shared_memory</strong> 将这份数据结构存入共享内存中，并且继续将这个指针传给 <strong>zend_accel_load_script</strong> 函数设置覆盖CG, EG等全局变量中对应的一些值，这种机制保证了这个扩展设计的初衷：<strong>每个 PHP 脚本只被编译一次</strong>。</p><p>下面这段代码展示的是 OPCache 将编译器结构替换成 persistent_script 的过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 替代 zend_compile_file 函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">accel_startup</span><span class="params">(zend_extension *extension)</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  accelerator_orig_compile_file = zend_compile_file;</span><br><span class="line">  zend_compile_file = persistent_compile_file;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function">zend_op_array *<span class="title">persistent_compile_file</span><span class="params">(zend_file_handle *file_handle, <span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (!ZCG(accel_directives).revalidate_path) &#123;</span><br><span class="line">            <span class="comment">/* 用与脚本一一对应的 key 在共享内存中查找缓存 */</span></span><br><span class="line">            key = accel_make_persistent_key(file_handle-&gt;filename, <span class="built_in">strlen</span>(file_handle-&gt;filename), &amp;key_length);</span><br><span class="line">            <span class="keyword">if</span> (!key) &#123;</span><br><span class="line">                <span class="keyword">return</span> accelerator_orig_compile_file(file_handle, type);</span><br><span class="line">            &#125;</span><br><span class="line">            persistent_script = zend_accel_hash_str_find(&amp;ZCSG(hash), key, key_length); <span class="comment">//从共享内存中取出 persistent_script</span></span><br><span class="line">        &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (!persistent_script) &#123;</span><br><span class="line"></span><br><span class="line">  from_shared_memory = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//如果缓存中没有, 调用 opcache_compile_file 进行初始化</span></span><br><span class="line">  persistent_script = opcache_compile_file(file_handle, type, key, key ? key_length : <span class="number">0</span>, &amp;op_array);</span><br><span class="line">  <span class="keyword">if</span> (persistent_script) &#123;</span><br><span class="line">            <span class="comment">// 初始化成功，调用 cache_script_in_shared_memory 写入共享内存</span></span><br><span class="line">            persistent_script = cache_script_in_shared_memory(persistent_script, key, key ? key_length : <span class="number">0</span>, &amp;from_shared_memory);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (!persistent_script) &#123;</span><br><span class="line">            SHM_PROTECT();</span><br><span class="line">            <span class="keyword">return</span> op_array;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">  <span class="comment">// 这里将从 共享内存/文件缓存（php7）中拿到的 persistent_script 拷贝到处理请求的进程内存中</span></span><br><span class="line">  <span class="keyword">return</span> zend_accel_load_script(persistent_script, from_shared_memory);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个 persistent_script</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> zend_persistent_script *<span class="title">opcache_compile_file</span><span class="params">(zend_file_handle *file_handle, <span class="keyword">int</span> type, <span class="keyword">char</span> *key, zend_op_array **op_array_p)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">new_persistent_script = create_persistent_script();</span><br><span class="line"><span class="comment">/* 保存一份原值 */</span></span><br><span class="line">orig_active_op_array = CG(active_op_array);</span><br><span class="line">orig_function_table = CG(function_table);</span><br><span class="line">orig_class_table = CG(class_table);</span><br><span class="line">ZVAL_COPY_VALUE(&amp;orig_user_error_handler, &amp;EG(user_error_handler));</span><br><span class="line"><span class="comment">/* 用新的结构替换 */</span></span><br><span class="line">CG(function_table) = &amp;ZCG(function_table);</span><br><span class="line">EG(class_table) = CG(class_table) = &amp;new_persistent_script-&gt;class_table;</span><br><span class="line">ZVAL_UNDEF(&amp;EG(user_error_handler));</span><br><span class="line">    zend_try &#123;</span><br><span class="line">        orig_compiler_options = CG(compiler_options);</span><br><span class="line">        CG(compiler_options) |= ZEND_COMPILE_HANDLE_OP_ARRAY;</span><br><span class="line">        CG(compiler_options) |= ZEND_COMPILE_IGNORE_INTERNAL_CLASSES;</span><br><span class="line">        CG(compiler_options) |= ZEND_COMPILE_DELAYED_BINDING;</span><br><span class="line">        CG(compiler_options) |= ZEND_COMPILE_NO_CONSTANT_SUBSTITUTION;</span><br><span class="line">        op_array = *op_array_p = accelerator_orig_compile_file(file_handle, type);</span><br><span class="line">        CG(compiler_options) = orig_compiler_options;</span><br><span class="line">    &#125; zend_catch &#123;</span><br><span class="line">        op_array = <span class="literal">NULL</span>;</span><br><span class="line">        do_bailout = <span class="number">1</span>;</span><br><span class="line">        CG(compiler_options) = orig_compiler_options;</span><br><span class="line">    &#125; zend_end_try();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Restore originals */</span></span><br><span class="line">    CG(active_op_array) = orig_active_op_array;</span><br><span class="line">    CG(function_table) = orig_function_table;</span><br><span class="line">    EG(class_table) = CG(class_table) = orig_class_table;</span><br><span class="line">    EG(user_error_handler) = orig_user_error_handler;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//end of *opcache_compile_file</span></span><br></pre></td></tr></table></figure><p>从代码中可以看出，在 OPCache 插件初始化函数 <strong>accel_startup</strong> 中，默认编译器 <strong>zend_compile_file</strong> 被替换成了 <strong>persistent_compile_file</strong>，而 persistent_compile_file 中如果从共享内存中拿不到 persistent_script(还有其他原因，比如过期等) 则会调用 <strong>opcache_compile_file</strong> 重新编译一份新的 <strong>persistent_script</strong>，并把得到的结果保存到共享内存中提供给其他的进程使用。</p><p>上面这段代码中，有四个编译选项被设置，分别是</p><ul><li><p>ZEND_COMPILE_HANDLE_OP_ARRAY</p><blockquote><p>启用 zend_extension_op_array_handler</p></blockquote></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (CG(compiler_options) &amp; ZEND_COMPILE_HANDLE_OP_ARRAY) &#123;</span><br><span class="line">        <span class="keyword">if</span> (zend_extension_flags &amp; ZEND_EXTENSIONS_HAVE_OP_ARRAY_HANDLER) &#123;</span><br><span class="line">            zend_llist_apply_with_argument(&amp;zend_extensions, (<span class="keyword">llist_apply_with_arg_func_t</span>) zend_extension_op_array_handler, op_array);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li><p>ZEND_COMPILE_IGNORE_INTERNAL_CLASSES</p><blockquote><p>忽略内部类</p></blockquote></li><li><p>ZEND_COMPILE_DELAYED_BINDING</p><blockquote><p>延迟绑定</p></blockquote></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (((ce = zend_lookup_class_ex(Z_STR_P(parent_name), parent_name + <span class="number">1</span>, <span class="number">0</span>)) == <span class="literal">NULL</span>) ||</span><br><span class="line">                    ((CG(compiler_options) &amp; ZEND_COMPILE_IGNORE_INTERNAL_CLASSES) &amp;&amp;</span><br><span class="line">                     (ce-&gt;type == ZEND_INTERNAL_CLASS))) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (CG(compiler_options) &amp; ZEND_COMPILE_DELAYED_BINDING) &#123;</span><br><span class="line">                        <span class="keyword">uint32_t</span> *opline_num = &amp;CG(active_op_array)-&gt;early_binding;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">while</span> (*opline_num != (<span class="keyword">uint32_t</span>)<span class="number">-1</span>) &#123;</span><br><span class="line">                            opline_num = &amp;CG(active_op_array)-&gt;opcodes[*opline_num].result.opline_num;</span><br><span class="line">                        &#125;</span><br><span class="line">                        *opline_num = opline - CG(active_op_array)-&gt;opcodes;</span><br><span class="line">                        opline-&gt;opcode = ZEND_DECLARE_INHERITED_CLASS_DELAYED;</span><br><span class="line">                        opline-&gt;result_type = IS_UNUSED;</span><br><span class="line">                        opline-&gt;result.opline_num = <span class="number">-1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><ul><li>ZEND_COMPILE_NO_CONSTANT_SUBSTITUTION</li></ul><blockquote><p>在编译阶段禁用常量代替</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (c &amp;&amp; (</span><br><span class="line">          ((c-&gt;flags &amp; CONST_PERSISTENT) &amp;&amp; !(CG(compiler_options) &amp; ZEND_COMPILE_NO_PERSISTENT_CONSTANT_SUBSTITUTION))</span><br><span class="line">       || (Z_TYPE(c-&gt;value) &lt; IS_OBJECT &amp;&amp; !(CG(compiler_options) &amp; ZEND_COMPILE_NO_CONSTANT_SUBSTITUTION))</span><br><span class="line">    )) &#123;</span><br><span class="line">        ZVAL_DUP(zv, &amp;c-&gt;value);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Substitute true, false and null (including unqualified usage in namespaces) */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *lookup_name = ZSTR_VAL(name);</span><br><span class="line">        <span class="keyword">size_t</span> lookup_len = ZSTR_LEN(name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!is_fully_qualified) &#123;</span><br><span class="line">            zend_get_unqualified_name(name, &amp;lookup_name, &amp;lookup_len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        c = zend_lookup_reserved_const(lookup_name, lookup_len);</span><br><span class="line">        <span class="keyword">if</span> (c) &#123;</span><br><span class="line">            ZVAL_DUP(zv, &amp;c-&gt;value);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这几个选项主要是为了告诉编译器少做点无用功，让 OPCache 只做它能做和该做的事情。</p><p>OPCache 关注下面几种数据结构：</p><ul><li>脚本中的函数 CG(function_table);</li><li>脚本中的类 CG(class_table);</li><li>脚本的 OPArray CG(active_op_array)</li><li>脚本的文件路径</li><li>脚本内容本身</li></ul><p>OPCache 在内存管理上非常聪明，它知道它该做的事情是什么：尽量快的读写缓存。所以它不会释放内存，过期的内容占用的地址空间会被置为 wasted , 这中设计最大化的减少了内存碎片的产生，每当达到设置的内存使用上限时，会触发一次 重启，相比较花大量的精力去管理内存空间，却只是为了应付大量的 http 短连接，一次简单的重启更实用。</p><p>上面提到的缓存的第一步是计算数据大小，下面是它的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint <span class="title">zend_accel_script_persist_calc</span><span class="params">(zend_persistent_script *new_persistent_script, <span class="keyword">char</span> *key, <span class="keyword">unsigned</span> <span class="keyword">int</span> key_length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    new_persistent_script-&gt;mem = <span class="literal">NULL</span>;</span><br><span class="line">    new_persistent_script-&gt;size = <span class="number">0</span>;</span><br><span class="line">    new_persistent_script-&gt;arena_mem = <span class="literal">NULL</span>;</span><br><span class="line">    new_persistent_script-&gt;arena_size = <span class="number">0</span>;</span><br><span class="line">    new_persistent_script-&gt;corrupted = <span class="number">0</span>;</span><br><span class="line">    ZCG(current_persistent_script) = new_persistent_script;</span><br><span class="line"></span><br><span class="line">    ADD_DUP_SIZE(new_persistent_script, <span class="keyword">sizeof</span>(zend_persistent_script));</span><br><span class="line">    <span class="keyword">if</span> (key) &#123;``</span><br><span class="line">        ADD_DUP_SIZE(key, key_length + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* script is not going to be saved in SHM */</span></span><br><span class="line">        new_persistent_script-&gt;corrupted = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ADD_STRING(new_persistent_script-&gt;full_path);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __SSE2__</span></span><br><span class="line">    <span class="comment">/* Align size to 64-byte boundary */</span></span><br><span class="line">    new_persistent_script-&gt;size = (new_persistent_script-&gt;size + <span class="number">63</span>) &amp; ~<span class="number">63</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    zend_accel_persist_class_table_calc(&amp;new_persistent_script-&gt;class_table);</span><br><span class="line">    zend_hash_persist_calc(&amp;new_persistent_script-&gt;function_table, zend_persist_op_array_calc);</span><br><span class="line">    zend_persist_op_array_calc_ex(&amp;new_persistent_script-&gt;main_op_array);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __SSE2__</span></span><br><span class="line">    <span class="comment">/* Align size to 64-byte boundary */</span></span><br><span class="line">    new_persistent_script-&gt;arena_size = (new_persistent_script-&gt;arena_size + <span class="number">63</span>) &amp; ~<span class="number">63</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    new_persistent_script-&gt;size += new_persistent_script-&gt;arena_size;</span><br><span class="line">    new_persistent_script-&gt;corrupted = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ZCG(current_persistent_script) = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_persistent_script-&gt;size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面计算地址空间大小的实现就看出我们缓存的内容是：</p><ul><li>脚本中的函数 &amp;new_persistent_script-&gt;function_table</li><li>脚本中的类 &amp;new_persistent_script-&gt;class_table</li><li>脚本的 OPArray &amp;new_persistent_script-&gt;main_op_array</li><li>脚本的文件路径 new_persistent_script-&gt;full_path</li><li>脚本内容本身 sizeof(zend_persistent_script)</li></ul><p>小结一下缓存 OPCodes 的流程:</p><ul><li>使用与脚本一一对应的 key 去共享内存中查找已缓存的脚本<ul><li>如果找到了并且未过期，那就调用 <strong>zend_accel_load_script</strong> 将其拷贝到当前进程的堆栈中</li><li>如果未找到，则调用 <strong>opcache_compile_file</strong> 初始化，然后将新鲜的结果通过调用 <strong>cache_script_in_shared_memory</strong> 存入共享内存中</li></ul></li></ul><p>这里面会涉及到内存管理，在后面的篇幅中会介绍。</p><p>除了 OPCodes 可被缓存之外，Interned Strings 也可以被缓存。</p><h2 id="共享-Interned-Strings"><a href="#共享-Interned-Strings" class="headerlink" title="共享 Interned Strings"></a>共享 Interned Strings</h2><h3 id="什么是-Interned-Strings？"><a href="#什么是-Interned-Strings？" class="headerlink" title="什么是 Interned Strings？"></a>什么是 Interned Strings？</h3><p>Interned Strings 是 PHP5.4 之后加入的一种很成熟的内存优化机制，简单解释，当 PHP 编译器遇到一个字符串，它就会把它存入一段特殊的内存中，在之后每次碰到相同的字符串时会复用之前的指针。如果你想知道更深入的东西，可以读一下 <a href="http://jpauli.github.io/2015/09/18/php-string-management.html#interned-strings" target="_blank" rel="noopener">php string management</a> 。</p><h3 id="共享机制"><a href="#共享机制" class="headerlink" title="共享机制"></a>共享机制</h3><p>Interned Strings 的工作原理如下图：</p><p><img src="https://raw.githubusercontent.com/lephp/lephp.github.io/master/images/w1664.png" alt="php string"></p><p>不过，上面这种复用的方式是基于每个进程的，不同的进程之间并不能共享这块缓存。如下图所示：<br><img src="https://raw.githubusercontent.com/lephp/lephp.github.io/master/images/two-workers.png" alt="two workers"></p><p>这样在高并发的情况下会浪费大量宝贵的内存空间，但是如果使用如下的方式就能解决内存浪费的问题了：<br><img src="https://raw.githubusercontent.com/lephp/lephp.github.io/master/images/share-interned-strings.png" alt="share interned-strings"></p><p>使用 OPCache 把字符串都缓存在一个共享内存里就可以让这部分内容给进程池中的所有 php-fpm worker 读取了。通过调整 <strong>opcache.interned_strings_buffer</strong> 的值可以控制字符串的缓存占用的存储大小，如果太小的话， OPCache 并不会重启，只是 interned_strings_buffer 不能再增加了，不能命中的将会继续使用 php-fpm 处理请求的子进程自己的私有内存。所以如果允许的话，可以根据需要调大这个值。</p><blockquote><p>Interned Strings 就是 PHP 编译器运行过程中遇到的每一个字符串：变量名、类名、方法名、字符串值、注释，而且注释一般都是一大段文本，它们会吃掉很多内存！</p></blockquote><p>那么 OPCache 怎么实现这一机制呢？答案当然在源码里：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">accel_startup</span><span class="params">(zend_extension *extension)</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">switch</span> (zend_shared_alloc_startup(ZCG(accel_directives).memory_consumption)) &#123;</span><br><span class="line">    <span class="keyword">case</span> ALLOC_SUCCESS:</span><br><span class="line">      <span class="keyword">if</span> (zend_accel_init_shm() == FAILURE) &#123;</span><br><span class="line">        accel_startup_ok = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ALLOC_FAILURE:</span><br><span class="line">      accel_startup_ok = <span class="number">0</span>;</span><br><span class="line">      zend_accel_error(ACCEL_LOG_FATAL, <span class="string">"Failure to initialize shared memory structures - probably not enough shared memory."</span>);</span><br><span class="line">      <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    <span class="keyword">case</span> SUCCESSFULLY_REATTACHED:</span><br><span class="line">      zend_shared_alloc_lock();</span><br><span class="line">      accel_shared_globals = (zend_accel_shared_globals *) ZSMMG(app_shared_globals);</span><br><span class="line">      orig_new_interned_string = zend_new_interned_string;</span><br><span class="line">      orig_interned_strings_snapshot = zend_interned_strings_snapshot;</span><br><span class="line">      orig_interned_strings_restore = zend_interned_strings_restore;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 这里用 OPCache 中几个实现替代了原有的实现，用于当出现新的 interned string 时，写入共享内存</span></span><br><span class="line">      zend_new_interned_string = accel_new_interned_string_for_php;</span><br><span class="line">      zend_interned_strings_snapshot = accel_interned_strings_snapshot_for_php;</span><br><span class="line">      zend_interned_strings_restore = accel_interned_strings_restore_for_php;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">ifndef</span> ZTS</span></span><br><span class="line">      <span class="comment">// 当不是线程安全的时候，调用此函数将 interned strings 从共享内存中拷贝到当前进程内存中</span></span><br><span class="line">      accel_use_shm_interned_strings();</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      zend_shared_alloc_unlock();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FAILED_REATTACHED:</span><br><span class="line">      accel_startup_ok = <span class="number">0</span>;</span><br><span class="line">      zend_accel_error(ACCEL_LOG_FATAL, <span class="string">"Failure to initialize shared memory structures - can not reattach to exiting shared memory."</span>);</span><br><span class="line">      <span class="keyword">return</span> SUCCESS;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> ENABLE_FILE_CACHE_FALLBACK</span></span><br><span class="line">    <span class="keyword">case</span> ALLOC_FALLBACK:</span><br><span class="line">      zend_shared_alloc_lock();</span><br><span class="line">      fallback_process = <span class="number">1</span>;</span><br><span class="line">      zend_accel_init_auto_globals();</span><br><span class="line">      zend_shared_alloc_unlock();</span><br><span class="line">      <span class="keyword">goto</span> file_cache_fallback;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个实现的方式还是比较简单的，需要注意的是，这个特性不支持线程安全的PHP版本，前面有提到使用的 php-fpm 模式一个任务只由一个子进程处理，不存在线程安全隐忧，不需要特别使用线程安全版本的php，所以是可以享受到这个优势的。</p><p>讲到这里，我们已经把 OPCache 在缓存上的两个大的点覆盖到了：</p><ul><li>OPCodes 缓存</li><li>Interned Strings 共享</li></ul><p>这两者都和用于进程间资源共享的内存离不开，这块内存区域的管理对于性能提升也至关重要，这就引入了另一个话题，那就是锁。</p><h2 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h2><p>OPCache 的内存锁机制很简单：每个尝试往共享内存里写入内容的时候都会使用互斥锁，同时只有一个进程可以写，但是可以同时又很多进程同时读，写操作未完成时并不会阻止同时发生的读操作。</p><p>所以服务器运行过程中 OPCache 中出现死锁的概率比较低，但是每次你部署新的代码后，如果流量很大的话，可能会造成大量的写操作积压，这是因为当第一个获得写入机会的进程完成后，其他相同请求编译的结果会因为共享内存已经存在相同的内容而被其替代，这造成了极大的资源浪费，等于这些因为拿不到写机会的进程都干了无用功。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* exclusive lock */</span></span><br><span class="line">zend_shared_alloc_lock(TSRMLS_C);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if we still need to put the file into the cache (may be it was</span></span><br><span class="line"><span class="comment"> * already stored by another process. This final check is done under</span></span><br><span class="line"><span class="comment"> * exclusive lock) */</span></span><br><span class="line">bucket = zend_accel_hash_find_entry(&amp;ZCSG(hash), new_persistent_script-&gt;full_path, new_persistent_script-&gt;full_path_len + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (bucket) &#123;</span><br><span class="line">    zend_persistent_script *existing_persistent_script = (zend_persistent_script *)bucket-&gt;data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!existing_persistent_script-&gt;corrupted) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ZCG(accel_directives).revalidate_path &amp;&amp;</span><br><span class="line">            (!ZCG(accel_directives).validate_timestamps ||</span><br><span class="line">             (new_persistent_script-&gt;timestamp == existing_persistent_script-&gt;timestamp))) &#123;</span><br><span class="line">            zend_accel_add_key(key, key_length, bucket TSRMLS_CC);</span><br><span class="line">        &#125;</span><br><span class="line">        zend_shared_alloc_unlock(TSRMLS_C);</span><br><span class="line">        <span class="keyword">return</span> new_persistent_script;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么解决这个问题呢？有一种办法就是短暂（一秒内）切断服务，然后把所有的页面或接口都调用一遍，保证 OPCache 的共享内存中都已经刷新了一遍内容。这个方法很粗暴，从服务可用性角度说肯定有所损失，但是为了避免出现可能的死锁导致更严重的事故也许主动切断几秒服务可能，甚至前端配合消息队列等设计几乎可以将用户感知降到0，这方面这里就不赘述了。</p><p>另外一个问题更值得重视：避免在 php 脚本运行中写 .php 文件，然后还要去用它。原因是，一旦程序要使用一个在运行过程中动态生成的代码，并发量很高的时候意味着每一个 php worker 都会尝试去编译它，这就会导致锁的发生。如果你确实需要这么做，opcache 有一个选项可以配置黑名单： opcache.blacklist-filename。</p><p>从技术角度，OPCache 的锁机制并不是很健壮，但是它在 Unix 生态里有很好的兼容性，因为它使用的是 fcntl() 调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ext/opcache/zend_shared_alloc.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zend_shared_alloc_lock</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ZEND_WIN32</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ZTS</span></span><br><span class="line">tsrm_mutex_lock(zts_lock);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="comment">/* this will happen once per process, and will un-globalize mem_write_lock */</span></span><br><span class="line"><span class="keyword">if</span> (mem_write_lock.l_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">mem_write_lock.l_pid = getpid();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (fcntl(lock_file, F_SETLKW, &amp;mem_write_lock) == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">zend_accel_error(ACCEL_LOG_ERROR, <span class="string">"Cannot create lock - %s (%d)"</span>, strerror(errno), errno);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">zend_shared_alloc_lock_win32();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">ZCG(locked) = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="OPCache-对内存的使用"><a href="#OPCache-对内存的使用" class="headerlink" title="OPCache 对内存的使用"></a>OPCache 对内存的使用</h2><p>先回顾一下 OPCache 与内存相关的几个特点：</p><ul><li>OPCache 在 php-fpm 的 master 启动的时候就申请一块内存，所有的 slave 可共享</li><li>OPCache 不会释放共享内存</li><li>OPCache 在写共享内存的时候会使用 fcntl() 执行 F_SETLKW</li><li>共享内存用于以下几个方面<ul><li>脚本数据结构缓存，包括但不限于 OPCodes</li><li>Interned Strings 缓存</li><li>脚本的 HashTable</li><li>OPCache 的全局状态信息</li></ul></li></ul><p>这些特性对提升 web 服务性能帮助很大，但是：</p><blockquote><p>世界上没有什么是不过期的</p></blockquote><p>那 OPCache 怎么判断一个对象的缓存是否过期？阅读 opcache 的配置文档会发现两个很明显相关的选项：</p><ul><li>opcache.validate_timestamps</li><li>opcache.revalidate_freq</li><li>opcache.revalidate_path</li></ul><p>当 php.ini 中打开了 opcache.validate_timestamps 选项时，OPCache 的编译阶段（persistent_compile_file()）会调用 validate_timestamp_and_record() 检查缓存中脚本的时间戳和文件的时间戳。实现代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function">zend_op_array *<span class="title">persistent_compile_file</span><span class="params">(zend_file_handle *file_handle, <span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* If script is found then validate_timestamps if option is enabled */</span></span><br><span class="line"><span class="keyword">if</span> (persistent_script &amp;&amp; ZCG(accel_directives).validate_timestamps) &#123;</span><br><span class="line">    <span class="comment">// 校验时间戳</span></span><br><span class="line"><span class="keyword">if</span> (validate_timestamp_and_record(persistent_script, file_handle) == FAILURE) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">validate_timestamp_and_record</span><span class="params">(zend_persistent_script *persistent_script, zend_file_handle *file_handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ZCG(accel_directives).revalidate_freq &amp;&amp;</span><br><span class="line">    persistent_script-&gt;dynamic_members.revalidate &gt;= ZCG(request_time)) &#123;</span><br><span class="line">        <span class="comment">// 如果设置了 revalidate_freq 并且 缓存中的 persistent_script 存的下一次检查脚本时间仍然在请求发生之后，则不检查</span></span><br><span class="line"><span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (do_validate_timestamps(persistent_script, file_handle) == FAILURE) &#123;</span><br><span class="line">    <span class="comment">// else 检查时间戳</span></span><br><span class="line"><span class="keyword">return</span> FAILURE;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// else 检查通过，不需要更新缓存中的内容，但是更新 下一次检查时间</span></span><br><span class="line">persistent_script-&gt;dynamic_members.revalidate = ZCG(request_time) + ZCG(accel_directives).revalidate_freq;</span><br><span class="line"><span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">static</span> zend_persistent_script *<span class="title">opcache_compile_file</span><span class="params">(zend_file_handle *file_handle, <span class="keyword">int</span> type, <span class="keyword">char</span> *key, <span class="keyword">unsigned</span> <span class="keyword">int</span> key_length, zend_op_array **op_array_p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (ZCG(accel_directives).validate_timestamps) &#123;</span><br><span class="line"><span class="comment">/* Obtain the file timestamps, *before* actually compiling them,</span></span><br><span class="line"><span class="comment"> * otherwise we have a race-condition.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">new_persistent_script-&gt;timestamp = timestamp;</span><br><span class="line">    <span class="comment">// 记录下一次需要检查脚本是否变更的时间</span></span><br><span class="line">new_persistent_script-&gt;dynamic_members.revalidate = ZCG(request_time) + ZCG(accel_directives).revalidate_freq;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>那么，如果缓存过期了怎么办？再来看看这一段代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 校验时间戳</span></span><br><span class="line"><span class="keyword">if</span> (validate_timestamp_and_record(persistent_script, file_handle) == FAILURE) &#123;</span><br><span class="line">zend_shared_alloc_lock();</span><br><span class="line"><span class="keyword">if</span> (!persistent_script-&gt;corrupted) &#123;</span><br><span class="line">  persistent_script-&gt;corrupted = <span class="number">1</span>;</span><br><span class="line">  persistent_script-&gt;timestamp = <span class="number">0</span>;</span><br><span class="line">  ZSMMG(wasted_shared_memory) += persistent_script-&gt;dynamic_members.memory_consumption;</span><br><span class="line">  <span class="keyword">if</span> (ZSMMG(memory_exhausted)) &#123;</span><br><span class="line">    zend_accel_restart_reason reason =</span><br><span class="line">      zend_accel_hash_is_full(&amp;ZCSG(hash)) ? ACCEL_RESTART_HASH : ACCEL_RESTART_OOM;</span><br><span class="line">    zend_accel_schedule_restart_if_necessary(reason);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">zend_shared_alloc_unlock();</span><br><span class="line">persistent_script = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从中可以看出，OPCache 会首先调用 <strong>zend_shared_alloc_lock()</strong>，然后将 persistent_script 的 设置为 corrupted，然后再判断共享内存又没有被标记 memory_exhausted=1，如果已经满了，那就调用 <strong>zend_accel_schedule_restart_if_necessary();</strong>，这个函数的实现如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void zend_accel_schedule_restart_if_necessary(zend_accel_restart_reason reason)</span><br><span class="line">&#123;</span><br><span class="line">if ((((double) ZSMMG(wasted_shared_memory)) / ZCG(accel_directives).memory_consumption) &gt;= ZCG(accel_directives).max_wasted_percentage) &#123;</span><br><span class="line">    // 如果已经置为 wasted 的内存空间已经大于 php.ini 中设置的最大比例，则计划重启</span><br><span class="line"> zend_accel_schedule_restart(reason);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以，已经被设置为 wasted 的内存大于（opcache.max_wasted_percentage）设置的比例时，会触发 OPCache 的重启机制，它的重启机制是很复杂的，准备再另外一篇中重点解析。因为 OPCache 的重启是会锁住共享内存，重设状态，完全清理空间，然后再释放锁，一旦在流量很高的时候频繁触发重启，那带来的性能影响将是灾难性的。所以对性能有高要求的话有一条军规：</p><blockquote><p><strong>永远不要超出共享内存</strong></p></blockquote><p>如何做到这一点，或者说避免出现这种情况的做法是在线上服务器上关闭 validate_timestamps ，这种做法可以保证你永远不会触发重启，可以按照下面的步骤部署新的代码：</p><ul><li>切断流量</li><li>清空 Opcache，使用 opcache_reset() 或者直接重启 FPM</li><li>部署新版本代码</li><li>重启 FPM, 对所有的页面、接口都遍历执行一遍</li><li>切回流量</li></ul><p>这些步骤用几十行 shell 脚本就可以搞定，如果有一些请求一直无法结束导致 fpm 无法完成重启可以直接 kill -9 强制杀死进程。还有一种可靠的方式是：使用灰度发布，这种方式一般适用于大型线上项目，可以最大程度保证服务平滑切换。</p><p>另外和这个话题相关的有一个问题：<br>在部署代码的时候我们遇到过一个很常见的问题，那就是刚部署的代码不能立即看到效果，这让产品很抓狂。经过分析发现，这是因为部署代码的方式使用的是常见的先部署代码，再修改软连接的目标目录到新的代码目录下的方式，而 php-fpm 得到的访问请求是一个软连接，而缓存中 realpath_cache 仍然指向老的代码地址，故而新发布的代码没有生效。解决这个问题有多种办法，我们使用的是在 nginx 层配置成绝对路径，很好的解决了问题。</p><h1 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h1><p>到这里，OPCache 缓存部分的内容基本介绍完了，主要就是涉及到 OPCodes 缓存和 Interned Strings 缓存两大块，然后就是共享内存的管理也很重要，希望对大家开发和性能优化有一些指导意义，抽空再分析一下操作码优化这一块的内容。</p><p>因为个人能力有限，所以文中有一些不准确的地方敬请指出。<a href="mailto:vaivei@foxmail.com" target="_blank" rel="noopener">vaivei@foxmail.com</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>本文相当多的内容源自: <strong><a href="http://jpauli.github.io/2015/03/05/opcache.html" target="_blank" rel="noopener">PHP’s OPCache extension review</a></strong></p><ul><li><p><a href="http://huoding.com/2016/05/27/515" target="_blank" rel="noopener">如何正确发布PHP代码 - 火丁</a></p></li><li><p><a href="http://jpauli.github.io/2015/09/18/php-string-management.html" target="_blank" rel="noopener">PHP strings management</a></p></li><li><p><a href="http://php.net/manual/en/opcache.configuration.php" target="_blank" rel="noopener">opcache configuration</a></p></li><li><p><a href="http://taobaofed.org/blog/2015/11/24/nodejs-php-process-manager/" target="_blank" rel="noopener">浅谈 Node.js 和 PHP 进程管理</a></p></li><li><p><a href="https://github.com/php/php-src" target="_blank" rel="noopener">PHP 源代码</a></p></li><li><p>使用 <a href="http://opengrok.github.io/OpenGrok/" target="_blank" rel="noopener">Opengrok</a> 阅读源代码</p></li></ul>]]></content>
      
      
        <tags>
            
            <tag> opcache php optimization </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
